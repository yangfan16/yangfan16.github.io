<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/uploads/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon-16x16.png"><link rel="mask-icon" href="/uploads/safari-pinned-tab.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"blog.yangfan16.cn",root:"/",scheme:"Mist",version:"7.8.0",exturl:!1,sidebar:{position:"right",display:"hide",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!0,pangu:!0,comments:{style:"buttons",active:"gitalk",storage:!0,lazyload:!1,nav:null,activeClass:"gitalk"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!0,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="数组和切片是Go语言中常见的数据结构，很多刚刚使用Go的开发者往往会混淆这两个概念，数组作为最常见的集合在编程语言中是非常重要的，除了数组之外，Go 语言引入了另一个概念 — 切片，切片与数组有一些类似，但是它们的不同之处导致使用上会产生巨大的差别。我个人对于算法专项使用Go语言来进行练习，因此只涉及Go语言的部分实现和原理。"><meta property="og:type" content="article"><meta property="og:title" content="理解Go语言数组和切片"><meta property="og:url" content="https://blog.yangfan16.cn/go/go-slice-array/index.html"><meta property="og:site_name" content="青梅梦呓"><meta property="og:description" content="数组和切片是Go语言中常见的数据结构，很多刚刚使用Go的开发者往往会混淆这两个概念，数组作为最常见的集合在编程语言中是非常重要的，除了数组之外，Go 语言引入了另一个概念 — 切片，切片与数组有一些类似，但是它们的不同之处导致使用上会产生巨大的差别。我个人对于算法专项使用Go语言来进行练习，因此只涉及Go语言的部分实现和原理。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://images.yangfan16.cn/go-arrary.jpeg"><meta property="og:image" content="https://images.yangfan16.cn/go-arrary-global-memory.png"><meta property="og:image" content="https://images.yangfan16.cn/go-slice-struct.png"><meta property="og:image" content="https://images.yangfan16.cn/go-slice-append.jpeg"><meta property="og:image" content="https://images.yangfan16.cn/go-slice-copy.png"><meta property="article:published_time" content="2020-05-30T02:10:45.000Z"><meta property="article:modified_time" content="2020-06-02T14:41:26.628Z"><meta property="article:author" content="青梅煮马"><meta property="article:tag" content="go"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://images.yangfan16.cn/go-arrary.jpeg"><link rel="canonical" href="https://blog.yangfan16.cn/go/go-slice-array/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>理解Go语言数组和切片 | 青梅梦呓</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">青梅梦呓</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">和世界交手的这许多年，你是否光彩依旧，兴致盎然</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i> 关于</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/yangfan16" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.yangfan16.cn/go/go-slice-array/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="青梅煮马"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="青梅梦呓"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 理解Go语言数组和切片</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-05-30 10:10:45" itemprop="dateCreated datePublished" datetime="2020-05-30T10:10:45+08:00">2020-05-30</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>17k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>16 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>数组和切片是Go语言中常见的数据结构，很多刚刚使用Go的开发者往往会混淆这两个概念，数组作为最常见的集合在编程语言中是非常重要的，除了数组之外，Go 语言引入了另一个概念 — 切片，切片与数组有一些类似，但是它们的不同之处导致使用上会产生巨大的差别。我个人对于算法专项使用Go语言来进行练习，因此只涉及Go语言的部分实现和原理。</p></blockquote><a id="more"></a><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的概念"><a href="#数组的概念" class="headerlink" title="数组的概念"></a>数组的概念</h3><p>数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问元素对应的存储地址，常见的数组大多都是一维的线性数组，而多维数组在数值和图形计算领域却有比较常见的应用1。</p><p><img data-src="https://images.yangfan16.cn/go-arrary.jpeg" alt="多维数组"></p><p>数组作为一种基本的数据类型，通常都会从两个维度描述数组，首先需要描述数组中存储的元素类型，还需要描述数组最大能够存储的元素个数，在 Go 语言中我们往往会使用如下所示的方式来表示数组类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>]<span class="keyword">string</span></span><br><span class="line">[<span class="number">200</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>与很多语言不同，Go 语言中数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一个类型。</p><p>查看Go语言的源代码，在<code>$GOROOT/src/cmd/compile/internal/types/type.go</code>文件中可以看到新建一个数组的时候发生了什么事情：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewArray returns a new fixed-length array Type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArray</span><span class="params">(elem *Type, bound <span class="keyword">int64</span>)</span> *<span class="title">Type</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> bound &lt; <span class="number">0</span> &#123;</span><br><span class="line">		Fatalf(<span class="string">"NewArray: invalid bound %v"</span>, bound)</span><br><span class="line">	&#125;</span><br><span class="line">	t := New(TARRAY)</span><br><span class="line">	t.Extra = &amp;Array&#123;Elem: elem, Bound: bound&#125;</span><br><span class="line">	t.SetNotInHeap(elem.NotInHeap())</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go程序编译期间，数组的类型由上述<code>NewArray</code>函数生成，类型 <code>Array</code> 包含两个字段，一个是元素类型 <code>Elem</code>，另一个是数组的大小 <code>Bound</code>，这两个字段共同构成了数组类型，而当前数组是否应该在堆还是栈中初始化也在编译期就确定了。</p><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>Go 语言中的数组有两种不同的创建方式，一种是显式的指定数组的大小，另一种是使用 […]T 声明数组，Go 语言会在编译期间通过源代码对数组的大小进行推断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">arr2 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>上述两种声明方式在运行期间得到的结果是完全相同的，后面的那种方式会被『转换』成为前一种，这个就是编译器对数组大小的推导</p><h4 id="数组大小推导过程"><a href="#数组大小推导过程" class="headerlink" title="数组大小推导过程"></a>数组大小推导过程</h4><p>上述两种不同的声明方式会导致编译器做出完全不同的处理，如果我们使用第一种方式 [5]T，那么变量的类型在编译进行到类型检查阶段就会被提取出来，随后会使用<code>cmd/compile/internal/types/type.go</code>中的<code>NewArrary</code>函数创建包含数组大小的 Array 类型。</p><p>当我们使用 <code>[...]T</code> 的方式声明数组时，虽然在这一步也会创建一个 <code>Array</code> 类型 <code>Array{Elem: elem, Bound: -1}</code>，但是其中的数组大小上限会是 -1，这里的 -1 只是一个占位符，编译器会在后面的 <code>cmd/compile/internal/gc/typecheck.go</code>文件中的 函数中对该数组的大小进行推导，具体的代码如下：</p><p>这个<code>typecheckcomplit</code>函数使用一个<code>typecheckarraylit</code>的函数来确定数组中元素的数量。我们继续往下追</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The result of typecheckcomplit MUST be assigned back to n, e.g.</span></span><br><span class="line"><span class="comment">// 	n.Left = typecheckcomplit(n.Left)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheckcomplit</span><span class="params">(n *Node)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Need to handle [...]T arrays specially.</span></span><br><span class="line">	<span class="keyword">if</span> n.Right.Op == OTARRAY &amp;&amp; n.Right.Left != <span class="literal">nil</span> &amp;&amp; n.Right.Left.Op == ODDD &#123;</span><br><span class="line">		n.Right.Right = typecheck(n.Right.Right, ctxType)</span><br><span class="line">		<span class="keyword">if</span> n.Right.Right.Type == <span class="literal">nil</span> &#123;</span><br><span class="line">			n.Type = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> n</span><br><span class="line">		&#125;</span><br><span class="line">		elemType := n.Right.Right.Type</span><br><span class="line"></span><br><span class="line">		length := typecheckarraylit(elemType, <span class="number">-1</span>, n.List.Slice(), <span class="string">"array literal"</span>)</span><br><span class="line"></span><br><span class="line">		n.Op = OARRAYLIT</span><br><span class="line">		n.Type = types.NewArray(elemType, length)</span><br><span class="line">		n.Right = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typecheckarraylit type-checks a sequence of slice/array literal elements.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheckarraylit</span><span class="params">(elemType *types.Type, bound <span class="keyword">int64</span>, elts []*Node, ctx <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="comment">// If there are key/value pairs, create a map to keep seen</span></span><br><span class="line">	<span class="comment">// keys so we can check for duplicate indices.</span></span><br><span class="line">	<span class="keyword">var</span> indices <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> _, elt := <span class="keyword">range</span> elts &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    key++</span><br><span class="line">		<span class="keyword">if</span> key &gt; length &#123;</span><br><span class="line">			length = key</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，Go1.14.2的代码中对于这种<code>[...]T</code>声明的数组，单独抽了一个方法，但是还是通过遍历每个元素的方式来确定数组的长度。 另外，因为声明这种数组时需要使用三个点（Dot），所以在编译器中就被称作 DDDArray。</p><p>所以我们可以看出 […]T{1, 2, 3} 和 [3]T{1, 2, 3} 在运行时是完全等价的，[…]T 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时就可以通过这种方法较少一些工作。</p><h4 id="语句转换"><a href="#语句转换" class="headerlink" title="语句转换"></a>语句转换</h4><p>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <code>cmd/compile/internal/gc/sinit.go</code>文件中的<code>anylit</code>函数中做两种不同的优化：</p><ul><li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li><li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anylit</span><span class="params">(n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	t := n.Type</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> OSTRUCTLIT, OARRAYLIT:</span><br><span class="line">		<span class="keyword">if</span> !t.IsStruct() &amp;&amp; !t.IsArray() &#123;</span><br><span class="line">			Fatalf(<span class="string">"anylit: not struct/array"</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> var_.isSimpleName() &amp;&amp; n.List.Len() &gt; <span class="number">4</span> &#123;</span><br><span class="line">			<span class="comment">// lay out static data</span></span><br><span class="line">			vstat := staticname(t)</span><br><span class="line">			vstat.Name.SetReadonly(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">			ctxt := inInitFunction</span><br><span class="line">			<span class="keyword">if</span> n.Op == OARRAYLIT &#123;</span><br><span class="line">				ctxt = inNonInitFunction</span><br><span class="line">			&#125;</span><br><span class="line">			fixedlit(ctxt, initKindStatic, n, vstat, init)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// copy static to var</span></span><br><span class="line">			a := nod(OAS, var_, vstat)</span><br><span class="line">    </span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><p>当数组的元素小于或者等于四个时，<code>cmd/compile/internal/gc/sinit.go</code>的文件中的<code>fixedlit</code>函数 会负责在函数编译之前将 [3]{1, 2, 3} 转换成更加原始的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/ fixedlit handles <span class="keyword">struct</span>, array, and slice literals.</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> expand documentation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fixedlit</span><span class="params">(ctxt initContext, kind initKind, n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> splitnode <span class="function"><span class="keyword">func</span><span class="params">(*Node)</span> <span class="params">(a *Node, value *Node)</span></span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> n.List.Slice() &#123;</span><br><span class="line">		a, value := splitnode(r)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> value.Op &#123;</span><br><span class="line">		<span class="keyword">case</span> OSLICELIT:</span><br><span class="line">			<span class="keyword">if</span> (kind == initKindStatic &amp;&amp; ctxt == inNonInitFunction) || (kind == initKindDynamic &amp;&amp; ctxt == inInitFunction) &#123;</span><br><span class="line">				slicelit(ctxt, value, a, init)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> OARRAYLIT, OSTRUCTLIT:</span><br><span class="line">			fixedlit(ctxt, kind, value, a, init)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		islit := isLiteral(value)</span><br><span class="line">		<span class="keyword">if</span> (kind == initKindStatic &amp;&amp; !islit) || (kind == initKindDynamic &amp;&amp; islit) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// build list of assignments: var[index] = expr</span></span><br><span class="line">		setlineno(a)</span><br><span class="line">		a = nod(OAS, a, value)</span><br><span class="line">		a = typecheck(a, ctxStmt)</span><br><span class="line">		<span class="keyword">switch</span> kind &#123;</span><br><span class="line">		<span class="keyword">case</span> initKindStatic:</span><br><span class="line">			genAsStatic(a)</span><br><span class="line">		<span class="keyword">case</span> initKindDynamic, initKindLocalCode:</span><br><span class="line">			a = orderStmtInPlace(a, <span class="keyword">map</span>[<span class="keyword">string</span>][]*Node&#123;&#125;)</span><br><span class="line">			a = walkstmt(a)</span><br><span class="line">			init.Append(a)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			Fatalf(<span class="string">"fixedlit: bad kind %d"</span>, kind)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>当数组中的元素数目小于四个的时候，<code>kind</code>的接受的值是<code>initKindLocalCode</code>，述代码会将原有的初始化语句 [3]int{1, 2, 3} 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>如果当前数组的元素大于 4 个，在上面的<code>anylit</code> 方法会先获取一个唯一的<code>staticname</code> ,然后会调用上面的<code>fixedlit</code>方法，在静态存储区初始化数组中的元素并将临时变量赋值给当前的数组。</p><p>总结起来，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件。</p><h3 id="访问和赋值"><a href="#访问和赋值" class="headerlink" title="访问和赋值"></a>访问和赋值</h3><p>无论是在栈上还是静态存储区，数组在内存中其实就是一连串的内存空间，表示数组的方法就是一个指向数组开头的指针、数组中元素的数量以及数组中元素类型占的空间大小，如果我们不知道数组中元素的数量，访问时就可能发生越界，而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据，如果没有这些信息，我们就无法知道这片连续的内存空间到底存储了什么数据：</p><p><img data-src="https://images.yangfan16.cn/go-arrary-global-memory.png" alt="数组内存结构"></p><p>数组访问越界是非常严重的错误，Go 语言中对越界的判断是可以在编译期间由静态类型检查完成的，<code>cmd/compile/internal/gc/typecheck.go</code>中的<code>typecheck1</code>函数会对访问数组的索引进行验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The result of typecheck1 MUST be assigned back to n, e.g.</span></span><br><span class="line"><span class="comment">// 	n.Left = typecheck1(n.Left, top)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> enableTrace &amp;&amp; trace &#123;</span><br><span class="line">		<span class="keyword">defer</span> tracePrint(<span class="string">"typecheck1"</span>, n)(&amp;res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OLITERAL, ONAME, ONONAME, OTYPE:</span><br><span class="line">		<span class="keyword">if</span> n.Sym == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> n.Op == ONAME &amp;&amp; n.SubOp() != <span class="number">0</span> &amp;&amp; top&amp;ctxCallee == <span class="number">0</span> &#123;</span><br><span class="line">			yyerror(<span class="string">"use of builtin %v not in function call"</span>, n.Sym)</span><br><span class="line">			n.Type = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> n</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !n.Bounded() &amp;&amp; Isconst(n.Right, CTINT) &#123;</span><br><span class="line">				x := n.Right.Int64()</span><br><span class="line">				<span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">					yyerror(<span class="string">"invalid %s index %v (index must be non-negative)"</span>, why, n.Right)</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.IsArray() &amp;&amp; x &gt;= t.NumElem() &#123;</span><br><span class="line">					yyerror(<span class="string">"invalid array index %v (out of bounds for %d-element array)"</span>, n.Right, t.NumElem())</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> Isconst(n.Left, CTSTR) &amp;&amp; x &gt;= <span class="keyword">int64</span>(<span class="built_in">len</span>(strlit(n.Left))) &#123;</span><br><span class="line">					yyerror(<span class="string">"invalid string index %v (out of bounds for %d-byte string)"</span>, n.Right, <span class="built_in">len</span>(strlit(n.Left)))</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> n.Right.Val().U.(*Mpint).Cmp(maxintval[TINT]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">					yyerror(<span class="string">"invalid %s index %v (index too large)"</span>, why, n.Right)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">      ...</span><br></pre></td></tr></table></figure><ul><li>访问数组的索引是非整数时会直接报错 —— non-integer array index %v；</li><li>访问数组的索引是负数时会直接报错 —— “invalid array index %v (index must be non-negative)”；</li><li>访问数组的索引越界时会直接报错 —— “invalid array index %v (out of bounds for %d-element array)”；</li></ul><p>数组和字符串的一些简单越界错误都会在编译期间发现，直接使用整数或者常量访问数组，但是如果使用变量去访问数组或者字符串时，编译器就无法发现对应的错误了，这时就需要 Go 语言运行时发挥作用了；Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 panicIndex 和 runtime.goPanicIndex 函数触发程序的运行时错误并导致崩溃退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·panicIndex(SB),NOSPLIT,$<span class="number">0</span><span class="number">-8</span></span><br><span class="line">	MOVL	AX, x+<span class="number">0</span>(FP)</span><br><span class="line">	MOVL	CX, y+<span class="number">4</span>(FP)</span><br><span class="line">	JMP	runtime·goPanicIndex(SB)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goPanicIndex</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	panicCheck1(getcallerpc(), <span class="string">"index out of range"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(boundsError&#123;x: <span class="keyword">int64</span>(x), signed: <span class="literal">true</span>, y: y, code: boundsIndex&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，而在运行期间这些插入的函数会负责保证不会发生越界错误。</p><p>数组的赋值和更新操作也会生成 SSA ，生成期间计算出数组当前元素的内存地址，然后修改当前内存地址的内容。</p><p>赋值的过程中会先确定目标数组的地址，再通过 PtrIndex 获取目标元素的地址，最后使用 Store 指令将数据存入地址中，从上面的这些 SSA 代码中我们可以看出无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>数组在Go语言中其实并不常用，更常用的数据结构是切片，切片就是动态数组，其长度并不固定，我们可以随意向切片中追加元素，而且切片会在容量不足的时候自动扩容。</p><p>切片类型的声明方式与数组有一些相似，由于切片的长度是动态的，所以声明时只需要指定切片中的元素类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]<span class="keyword">int</span></span><br><span class="line">[]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>从切片的定义能推测出，切片在编译期间的生成的类型只会包含切片中的元素类型，即<code>int</code>或者 <code>interface{}</code> 等。<code>ccmd/compile/internal/types/type.go</code>文件中的<code>NewSlice</code>方法就是编译期间用于创建 Slice 类型的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSlice returns the slice Type with element type elem.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlice</span><span class="params">(elem *Type)</span> *<span class="title">Type</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t := elem.Cache.slice; t != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t.Elem() != elem &#123;</span><br><span class="line">			Fatalf(<span class="string">"elem mismatch"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t := New(TSLICE)</span><br><span class="line">	t.Extra = Slice&#123;Elem: elem&#125;</span><br><span class="line">	elem.Cache.slice = t</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法返回的结构体<code>TSLICE</code> 中的 <code>Extra</code> 字段是一个只包含切片内元素类型的 <code>Slice{Elem: elem}</code> 结构，也就是说切片内元素的类型是在编译期间确定的，编译器确定了类型之后，会将类型存储在 Extra 字段中帮助程序在运行时动态获取。</p><h3 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h3><p>编译期间的切片是 Slice 类型的，但是在运行时切片由如下的 SliceHeader 结构体表示，其中 Data 字段是指向数组的指针，Len 表示当前切片的长度，而 Cap 表示当前切片的容量，也就是 Data 数组的大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SliceHeader is the runtime representation of a slice.</span></span><br><span class="line"><span class="comment">// It cannot be used safely or portably and its representation may</span></span><br><span class="line"><span class="comment">// change in a later release.</span></span><br><span class="line"><span class="comment">// Moreover, the Data field is not sufficient to guarantee the data</span></span><br><span class="line"><span class="comment">// it references will not be garbage collected, so programs must keep</span></span><br><span class="line"><span class="comment">// a separate, correctly typed pointer to the underlying data.</span></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">	Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Data</code>作为一个指针，指向的数组是一片连续的内存空间。这片内存空间可以用于存储切片中保存的所有元素。数组中的元素只逻辑上的概念，底层的存储其实都是连续的。所以可以将切片理解成一片连续的内存空间加上长度与容量的标识。</p><p><img data-src="https://images.yangfan16.cn/go-slice-struct.png" alt="Go切片结构"></p><p>官方解释Slice就是底层数组的一个View，切片引入了一个抽象层，提供了对数组中部分片段的引用，作为数组的引用，我们可以在运行区间可以修改它的长度，如果底层的数组长度不足就会触发扩容机制，切片中的数组就会发生变化，不过在上层看来切片时没有变化的，上层只需要与切片打交道不需要关心底层的数组变化。</p><p>Go语言获取数组大小、对数组中的元素的读写在编译期间就已经进行了简化，由于数组的内存固定且连续，很多操作都会变成对内存的直接读写；但是切片是运行时才会确定内容的结构，所有的操作还需要依赖 Go 语言的运行时来完成。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Go切片初始化有三种方式：</p><ol><li>通过下标的方式获得数组或者切片的一部分；</li><li>使用字面量初始化新的切片；</li><li>使用关键字<code>make</code>创建切片：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[0:3] or slice[0:3]</span><br><span class="line">slice :&#x3D; []int&#123;1, 2, 3&#125;</span><br><span class="line">slice :&#x3D; make([]int, 10)</span><br></pre></td></tr></table></figure></li></ol><h4 id="使用下标"><a href="#使用下标" class="headerlink" title="使用下标"></a>使用下标</h4><p>这是最原始，最底层，也是最接近汇编语言的方式，这种操作会被编译器转换为<code>OpSliceMake</code>操作，<br>在<code>cmd/compile/internal/types/type.go</code>文件中的<code>NewSlice</code>可以看到具体操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSlice returns the slice Type with element type elem.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlice</span><span class="params">(elem *Type)</span> *<span class="title">Type</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t := elem.Cache.slice; t != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t.Elem() != elem &#123;</span><br><span class="line">			Fatalf(<span class="string">"elem mismatch"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t := New(TSLICE)</span><br><span class="line">	t.Extra = Slice&#123;Elem: elem&#125;</span><br><span class="line">	elem.Cache.slice = t</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以写一段简单的代码看一下发生了什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSlice</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	arr := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	slice := arr[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">	<span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := newSlice()</span><br><span class="line">	fmt.Print(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>GOSSAFUNC</code> 生成中间代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ GOSSAFUNC=main <span class="keyword">go</span> build op_slice_make.<span class="keyword">go</span></span><br><span class="line"># runtime</span><br><span class="line">dumped SSA to /usr/local/<span class="keyword">go</span>/src/runtime/ssa.html</span><br><span class="line"># command-line-arguments</span><br><span class="line">dumped SSA to ./ssa.html</span><br></pre></td></tr></table></figure><p>可以在<code>decompose builtin</code>阶段，<code>slice := arr[0:3]</code> 对应的部分:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name &amp;arr[*[<span class="number">6</span>]<span class="keyword">int</span>]: v11</span><br><span class="line">name slice.ptr[*<span class="keyword">int</span>]: v11</span><br><span class="line">name slice.<span class="built_in">len</span>[<span class="keyword">int</span>]: v14</span><br><span class="line">name slice.<span class="built_in">cap</span>[<span class="keyword">int</span>]: v17</span><br></pre></td></tr></table></figure><p>也就是说其实切片的底层是数组，只是包含了三个部分:数组指针，切片大小和容量。同时在SSA中还可以看到<code>v27 (7) = SliceMake &lt;[]int&gt; v11 v25 v26 (~r0[[]int], slice[[]int], s[[]int])</code> , <code>SliceMake</code> 这个操作需要接受元素类型，数组指针，切片大小和切片容量来创建新的切片。</p><h4 id="使用字面量"><a href="#使用字面量" class="headerlink" title="使用字面量"></a>使用字面量</h4><p>我们除了使用下标的方式创建切片，还可以使用字面量来创建切片<code>[]int{1,2,3,4,5}</code>,在<code>cmd/compile/internal/gc/sinit.go</code>文件的<code>slicelit</code>函数会将这个展开成为下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vstat [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">vstat[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">vstat[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">vstat[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">vstat[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">vstat[<span class="number">4</span>] = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> vauto *[<span class="number">5</span>]<span class="keyword">int</span> = <span class="built_in">new</span>([<span class="number">5</span>]<span class="keyword">int</span>)</span><br><span class="line">*vauto = vstat</span><br><span class="line">slice := vauto[:]</span><br></pre></td></tr></table></figure><ul><li>根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</li><li>将这些字面量元素存储到初始化的数组中；</li><li>建一个同样指向 [5]int 类型的数组指针；</li><li>将静态存储区的数组 vstat 赋值给 vauto 指针所在的地址；</li><li>通过 [:] 操作获取一个底层使用 vauto 的切片；</li></ul><p>我们能看到租后进行的<code>[:]</code>其实是创建切片的真实方法，也就是说<code>[:]</code>操作是创建切片最底层的一种方法。</p><h4 id="使用make关键字"><a href="#使用make关键字" class="headerlink" title="使用make关键字"></a>使用make关键字</h4><p>使用字面量的方式创建切片，大部分的工作就都会在编译期间完成，但是当我们使用 make 关键字创建切片时，很多工作都需要运行时的参与；调用方必须在 make 函数中传入一个切片的大小以及可选的容量。<br>在<code>cmd/compile/internal/gc/typecheck.go</code>文件的<code>typecheck1</code>方法中能看到,make的时候会对参数进行校验：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">case</span> OMAKE:</span><br><span class="line">		ok |= ctxExpr</span><br><span class="line">		args := n.List.Slice()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">			yyerror(<span class="string">"missing argument to make"</span>)</span><br><span class="line">			n.Type = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> n</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n.List.Set(<span class="literal">nil</span>)</span><br><span class="line">   </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">case</span> TSLICE:</span><br><span class="line">			<span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(args) &#123;</span><br><span class="line">				yyerror(<span class="string">"missing len argument to make(%v)"</span>, t)</span><br><span class="line">				n.Type = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			l = args[i]</span><br><span class="line">			i++</span><br><span class="line">			l = typecheck(l, ctxExpr)</span><br><span class="line">			<span class="keyword">var</span> r *Node</span><br><span class="line">			<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123;</span><br><span class="line">				r = args[i]</span><br><span class="line">				i++</span><br><span class="line">				r = typecheck(r, ctxExpr)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> l.Type == <span class="literal">nil</span> || (r != <span class="literal">nil</span> &amp;&amp; r.Type == <span class="literal">nil</span>) &#123;</span><br><span class="line">				n.Type = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !checkmake(t, <span class="string">"len"</span>, l) || r != <span class="literal">nil</span> &amp;&amp; !checkmake(t, <span class="string">"cap"</span>, r) &#123;</span><br><span class="line">				n.Type = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> Isconst(l, CTINT) &amp;&amp; r != <span class="literal">nil</span> &amp;&amp; Isconst(r, CTINT) &amp;&amp; l.Val().U.(*Mpint).Cmp(r.Val().U.(*Mpint)) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				yyerror(<span class="string">"len larger than cap in make(%v)"</span>, t)</span><br><span class="line">				n.Type = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.Left = l</span><br><span class="line">			n.Right = r</span><br><span class="line">			n.Op = OMAKESLICE</span><br><span class="line">           </span><br><span class="line">          ...</span><br><span class="line">      </span><br><span class="line">      ...</span><br></pre></td></tr></table></figure><p>这个<code>typecheck1</code>函数不仅会检查<code>len</code>是否传入，还会保证传入的容量 <code>cap</code> 一定大于或者等于 <code>len</code>，除了校验参数之外，当前函数会将 <code>OMAKE</code> 节点转换成 <code>OMAKESLICE</code>，随后的中间代码生成阶段在 <code>cmd/compile/internal/gc/walk.go</code>文件中的<code>walkexpr</code> 函数中的 <code>OMAKESLICE</code> 分支依据两个重要条件对这里的 <code>OMAKESLICE</code> 进行转换：</p><ol><li>切片的大小和容量是否足够小</li><li>切片是否发生了逃逸，最终在堆上初始化</li></ol><p>当发生逃逸后者非常大的时候，在<code>runtime/slice.go</code>文件中的<code>makeslice</code>函数可以看到:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> Produce a 'len out of range' error instead of a</span></span><br><span class="line">		<span class="comment">// 'cap out of range' error when someone does make([]T, bignumber).</span></span><br><span class="line">		<span class="comment">// 'cap out of range' is true too, but since the cap is only being</span></span><br><span class="line">		<span class="comment">// supplied implicitly, saying len is clearer.</span></span><br><span class="line">		<span class="comment">// See golang.org/issue/4085.</span></span><br><span class="line">		mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">		<span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">			panicmakeslicelen()</span><br><span class="line">		&#125;</span><br><span class="line">		panicmakeslicecap()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>mallocgc</code>函数中还有一大段的注释解释了如何尽可能节约分配堆内存的空间。</p><p>总之，就是说在分配的切片比较小的情况下，会初始化数组并且直接通过下转换的方式来得到数组的切片，这两部分操作都会在编译阶段完成，编译器会在栈上或者静态存储区创建数组；而分配比较大或者出现逃逸的情况下会在堆上初始化。</p><p><code>makeslice</code>函数主要工作就是计算当前切片占用的内存空间并在堆上申请一片连续的内存，它使用如下的方式计算占用的内存：</p><blockquote><p>内存空间 = 切片中元素大小 x 切片容量</p></blockquote><p>创建切片的过程中如果发生了以下错误就会直接导致程序触发运行时错误并崩溃：</p><ol><li>内存空间的大小发生了溢出</li><li>申请的内存大于最大可分配的内存；</li><li>传入的长度小于 0 或者长度大于容量；</li></ol><p>Go的内存分配器实在是过于复杂，半天没研究出来什么有用的信息，就先跳过。</p><p><code>makeslice</code>函数会返回指向底层数组的指针，之前版本的 <code>Go</code> 语言中，数组指针、长度和容量会被合成一个 <code>slice</code> 结构并返回。现在改为构建结构体<code>SliceHeader</code>，这工作就都交给 <code>runtime.makeslice</code>的调用方处理了，这些调用方会在编译期间构建切片结构体。Go官方说这个改动能够减少 <code>~0.2%</code> 的 <code>Go</code> 语言包大小并且能够减少 92 个 <code>panicindex</code> 的调用，占整个 Go 语言二进制的 <code>~3.5%1</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">	Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>对切片常见的操作就是获取它的长度或者容量，这两个不同的函数 <code>len</code> 和 <code>cap</code> 被 <code>Go</code> 语言的编译器看成是两种特殊的操作，即 <code>OLEN</code> 和 <code>OCAP</code>，它们会在 <code>SSA</code> 生成阶段被 <code>cmd/compile/internal/gc/ssa.go</code>文件中的<code>expr</code>函数转换成 <code>OpSliceLen</code> 和 <code>OpSliceCap</code> 操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// expr converts the expression n to ssa, adds it to s and returns the ssa result.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OLEN, OCAP:</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> n.Left.Type.IsSlice():</span><br><span class="line">                op := ssa.OpSliceLen</span><br><span class="line">                <span class="keyword">if</span> n.Op == OCAP &#123;</span><br><span class="line">                    op = ssa.OpSliceCap</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> s.newValue1(op, types.Types[TINT], s.expr(n.Left))</span><br><span class="line">            <span class="keyword">case</span> n.Left.Type.IsString(): <span class="comment">// string; not reachable for OCAP</span></span><br><span class="line">                <span class="keyword">return</span> s.newValue1(ssa.OpStringLen, types.Types[TINT], s.expr(n.Left))</span><br><span class="line">            <span class="keyword">case</span> n.Left.Type.IsMap(), n.Left.Type.IsChan():</span><br><span class="line">                <span class="keyword">return</span> s.referenceTypeBuiltin(n, s.expr(n.Left))</span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">// array</span></span><br><span class="line">                <span class="keyword">return</span> s.constInt(types.Types[TINT], n.Left.Type.NumElem())</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>len(slice)</code> 或者 <code>cap(slice)</code> 在一些情况下会被直接替换成切片的长度或者容量，不需要运行时从切片结构中获取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(SlicePtr (SliceMake ptr _ _ )) -&gt; ptr</span><br><span class="line">(SliceLen (SliceMake _ <span class="built_in">len</span> _)) -&gt; <span class="built_in">len</span></span><br><span class="line">(SliceCap (SliceMake _ _ <span class="built_in">cap</span>)) -&gt; <span class="built_in">cap</span></span><br></pre></td></tr></table></figure><p>除了获取切片的长度和容量之外，访问切片中元素使用的 OINDEX 操作也会在中间代码生成期间转换成对地址的直接访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OINDEX:</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> n.Left.Type.IsString():</span><br><span class="line">                <span class="keyword">if</span> n.Bounded() &amp;&amp; Isconst(n.Left, CTSTR) &amp;&amp; Isconst(n.Right, CTINT) &#123;</span><br><span class="line">                    <span class="comment">// Replace "abc"[1] with 'b'.</span></span><br><span class="line">                    <span class="comment">// Delayed until now because "abc"[1] is not an ideal constant.</span></span><br><span class="line">                    <span class="comment">// See test/fixedbugs/issue11370.go.</span></span><br><span class="line">                    <span class="keyword">return</span> s.newValue0I(ssa.OpConst8, types.Types[TUINT8], <span class="keyword">int64</span>(<span class="keyword">int8</span>(strlit(n.Left)[n.Right.Int64()])))</span><br><span class="line">                &#125;</span><br><span class="line">                a := s.expr(n.Left)</span><br><span class="line">                i := s.expr(n.Right)</span><br><span class="line">                <span class="built_in">len</span> := s.newValue1(ssa.OpStringLen, types.Types[TINT], a)</span><br><span class="line">                i = s.boundsCheck(i, <span class="built_in">len</span>, ssa.BoundsIndex, n.Bounded())</span><br><span class="line">                ptrtyp := s.f.Config.Types.BytePtr</span><br><span class="line">                ptr := s.newValue1(ssa.OpStringPtr, ptrtyp, a)</span><br><span class="line">                <span class="keyword">if</span> Isconst(n.Right, CTINT) &#123;</span><br><span class="line">                    ptr = s.newValue1I(ssa.OpOffPtr, ptrtyp, n.Right.Int64(), ptr)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ptr = s.newValue2(ssa.OpAddPtr, ptrtyp, ptr, i)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> s.load(types.Types[TUINT8], ptr)</span><br><span class="line">            <span class="keyword">case</span> n.Left.Type.IsSlice():</span><br><span class="line">                p := s.addr(n, <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> s.load(n.Left.Type.Elem(), p)</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，使用<code>range</code> 遍历切片时也会在编译期间转换成形式更简单的代码。</p><h3 id="range遍历"><a href="#range遍历" class="headerlink" title="range遍历"></a>range遍历</h3><h3 id="追加和扩容"><a href="#追加和扩容" class="headerlink" title="追加和扩容"></a>追加和扩容</h3><p>向切片中追加元素是非常常见的操作，在 <code>Go</code> 语言中我们会使用 <code>append</code> 关键字向切片追加元素，中间代码生成阶段的 <code>cmd/compile/internal/gc/ssa.go</code>文件中我们可以看到<code>append</code>方法，该方法追加元素会根据返回值是否会覆盖原变量，分别进入两种流程，如果 <code>append</code> 返回的『新切片』不需要赋值回原有的变量，就会进入如下的处理流程（代码中的注释）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := s</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> newlen &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">    ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> = growslice(s, newlen)</span><br><span class="line">	newlen = <span class="built_in">len</span> + <span class="number">3</span> <span class="comment">// recalculate to avoid a spill</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(ptr+<span class="built_in">len</span>) = e1</span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = e2</span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = e3</span><br><span class="line"><span class="keyword">return</span> makeslice(ptr, newlen, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>先对结构体进行解析，获取它的指针，大小和容量，如果在追加后切片的大小大于其容量，就会对切片进行扩容，使用的方法是<code>runtime/slice.go</code>文件中的<code>growslice</code>方法 ,扩容策略我们后面再讲；如果<code>append</code>后的切片会覆盖原来的切片，就会使用另一种方式改写关键字，在<code>cmd/compile/internal/gc/ssa.go</code>文件中<code>append</code>程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a := &amp;s</span><br><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := s</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uint</span>(newlen) &gt; <span class="keyword">uint</span>(<span class="built_in">cap</span>) &#123;</span><br><span class="line">    newptr, <span class="built_in">len</span>, newcap = growslice(ptr, <span class="built_in">len</span>, <span class="built_in">cap</span>, newlen)</span><br><span class="line">	vardef(a)       <span class="comment">// if necessary, advise liveness we are writing a new a</span></span><br><span class="line">	*a.<span class="built_in">cap</span> = newcap <span class="comment">// write before ptr to avoid a spill</span></span><br><span class="line">	*a.ptr = newptr <span class="comment">// with write barrier</span></span><br><span class="line">&#125;</span><br><span class="line">newlen = <span class="built_in">len</span> + <span class="number">3</span> <span class="comment">// recalculate to avoid a spill</span></span><br><span class="line">*a.<span class="built_in">len</span> = newlen</span><br><span class="line"><span class="comment">// with write barriers, if needed:</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>) = e1</span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = e2</span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = e3</span><br></pre></td></tr></table></figure><p>如果我们选择覆盖原有的变量，也不需要担心切片的拷贝，因为<code>Go</code>语言的编译器已经对这种情况作了优化。大概如下：</p><p><img data-src="https://images.yangfan16.cn/go-slice-append.jpeg" alt="slice扩容"></p><p>Go语言的切片扩容策略:</p><ol><li>如果期望容量大于当前容量的两倍就会使用期望容量；</li><li>如果当前切片容量小于 1024 就会将容量翻倍；</li><li>如果当前切片容量大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li></ol><p>在<code>runtime/slice.go</code>文件中的<code>growslice</code>方法中能看到如下的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>确定了切片的容量之后，就可以计算切片中新数组占用的内存了，计算的方法就是将目标容量和元素大小相乘，计算新容量时可能会发生溢出或者请求的内存超过上限，这个时候就会出现<code>panic</code>。</p><p>若切片中元素不是指针类型，那么就会调用 <code>memclrNoHeapPointers</code> 将超出切片当前长度的位置清空并在最后使用 <code>memmove</code> 将原数组内存中的内容拷贝到新申请的内存中。这里的<code>memclrNoHeapPointers</code> 和<code>memmove</code>都是用目标机器上的汇编指令实现的。</p><p><code>growslice</code>函数最终会返回一个新的<code>slice</code>结构，其中包含了新的数组指针、大小和容量，这个返回的三元组最终会改变原有的切片，帮助 append 完成元素追加的功能。</p><h3 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h3><p>拷贝切片并不常用，<code>Go</code>提供了一个内置的<code>copy(a,b)</code>,在<code>cmd/compile/internal/gc/walk.go</code>文件中<code>copyany</code>函数能看到具体的操作 其实是分了两种情况处理，如果<code>copy</code>不是运行时调用，<code>copy(a,b)</code>会被直接转换为下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="built_in">len</span>(b) &#123;</span><br><span class="line">    n = <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a.ptr != b.ptr &#123;</span><br><span class="line">    memmove(a.ptr, b.ptr, n*sizeof(elem(a))) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>memmove</code> 会负责对内存进行拷贝，在其他情况下，编译器会使用 <code>slicecopy</code> 函数替换运行期间调用的 <code>copy</code>，例如：`go copy(a, b)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(to, fm slice, width <span class="keyword">uintptr</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fm.<span class="built_in">len</span> == <span class="number">0</span> || to.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	n := fm.<span class="built_in">len</span></span><br><span class="line">	<span class="keyword">if</span> to.<span class="built_in">len</span> &lt; n &#123;</span><br><span class="line">		n = to.<span class="built_in">len</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	size := <span class="keyword">uintptr</span>(n) * width</span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">1</span> &#123;</span><br><span class="line">		*(*<span class="keyword">byte</span>)(to.array) = *(*<span class="keyword">byte</span>)(fm.array)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		memmove(to.array, fm.array, size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种不同的拷贝方式一般都会通过 memmove 将整块内存中的内容拷贝到目标的内存区域中,如下图所示：<br><img data-src="https://images.yangfan16.cn/go-slice-copy.png" alt="切片扩容"></p><p>相比于依次对元素进行拷贝，这种方式能够提供更好的性能，但是需要注意的是，哪怕使用 <code>memmove</code> 对内存成块进行拷贝，但是这个操作还是会占用非常多的资源，在大切片上执行拷贝操作时一定要注意性能影响。</p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/go/actions-go/" rel="bookmark">GitHub Actions 自动化构建Go应用</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/go/go-map/" rel="bookmark">理解Go语言的哈希表</a></div></li></ul><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 青梅煮马</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://blog.yangfan16.cn/go/go-slice-array/" title="理解Go语言数组和切片">https://blog.yangfan16.cn/go/go-slice-array/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/go/" rel="tag"><i class="fa fa-tag"></i> go</a></div><div class="post-widgets"><div class="wp_rating"><div id="wpac-rating"></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/go/go-leetcode-slice/" rel="prev" title="数组算法训练"><i class="fa fa-chevron-left"></i> 数组算法训练</a></div><div class="post-nav-item"> <a href="/go/actions-go/" rel="next" title="GitHub Actions 自动化构建Go应用">GitHub Actions 自动化构建Go应用<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的概念"><span class="nav-number">1.1.</span> <span class="nav-text">数组的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组初始化"><span class="nav-number">1.2.</span> <span class="nav-text">数组初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组大小推导过程"><span class="nav-number">1.2.1.</span> <span class="nav-text">数组大小推导过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语句转换"><span class="nav-number">1.2.2.</span> <span class="nav-text">语句转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问和赋值"><span class="nav-number">1.3.</span> <span class="nav-text">访问和赋值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切片"><span class="nav-number">2.</span> <span class="nav-text">切片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#切片类型"><span class="nav-number">2.1.</span> <span class="nav-text">切片类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">2.2.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用下标"><span class="nav-number">2.2.1.</span> <span class="nav-text">使用下标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用字面量"><span class="nav-number">2.2.2.</span> <span class="nav-text">使用字面量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用make关键字"><span class="nav-number">2.2.3.</span> <span class="nav-text">使用make关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问元素"><span class="nav-number">2.3.</span> <span class="nav-text">访问元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range遍历"><span class="nav-number">2.4.</span> <span class="nav-text">range遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#追加和扩容"><span class="nav-number">2.5.</span> <span class="nav-text">追加和扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切片拷贝"><span class="nav-number">2.6.</span> <span class="nav-text">切片拷贝</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="青梅煮马" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">青梅煮马</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/yangfan16" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yangfan16" rel="noopener" target="_blank"><i class="github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:yangfan9915@gmail.com" title="E-Mail → mailto:yangfan9915@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://weibo.com/52012536" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;52012536" rel="noopener" target="_blank"><i class="weibo fa-fw"></i> Weibo</a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="link fa-fw"></i> 大佬博客链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://think2011.net/" title="https:&#x2F;&#x2F;think2011.net&#x2F;" rel="noopener" target="_blank">曾浩的博客</a></li><li class="links-of-blogroll-item"> <a href="https://ninghao.net/blog" title="https:&#x2F;&#x2F;ninghao.net&#x2F;blog" rel="noopener" target="_blank">王皓的博客</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备17005352号-2</a> <img src="/uploads/beian.png" style="display:inline-block"></div><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">青梅煮马</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">88k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">1:20</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e79f11b160a4070" async="async"></script></div></div></footer></div><script size="200" alpha="0.4" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/lozad.js/1.14.0/lozad.min.js"></script><script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script><script data-pjax>CONFIG.page.isPost&&(wpac_init=window.wpac_init||[],wpac_init.push({widget:"Rating",id:10254,el:"wpac-rating",color:"fc6423"}),function(){if(!("WIDGETPACK_LOADED"in window)){WIDGETPACK_LOADED=!0;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//embed.widgetpack.com/widget.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t.nextSibling)}}())</script><div id="pjax"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'f9f42cb27214f7d10b14',
      clientSecret: '147d85755db76790cff0442b7f5123e0032cba08',
      repo        : 'gitalk',
      owner       : 'yangfan16',
      admin       : ['yangfan16'],
      id          : '5cf7b7e57167cf03469a98239d6133c7',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></div></body></html>