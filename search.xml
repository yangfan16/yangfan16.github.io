<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GitHub Actions 自动化构建Go应用</title>
    <url>/go/actions-go/</url>
    <content><![CDATA[<blockquote>
<p>欧老板昨天问我怎么让自己的go程序使用github-actions，给欧老板做了一个简单的demo， 一个beego的程序，随便写了点单测的代码。一个基本的 Pipeline，推送代码到 master 分支的时候就会触发该 Pipeline 的自动构建，进行代码的静态化检查操作、运行单元测试并使用 Codecov 生成代码覆盖率报告，部署到Netlify，并且根据Dockerfile生成Docker镜像。</p>
</blockquote>
<a id="more"></a>


<h2 id="Golang-项目"><a href="#Golang-项目" class="headerlink" title="Golang 项目"></a>Golang 项目</h2><h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p>主要是为了演示GitHub Actions的功能，欧老板说他用的beego,我就构建一个最简单的”Hello world”的 beego 程序，其中就包含一个基本的 Pipeline，推送代码到 master 分支的时候就会触发该 Pipeline 的自动构建，进行代码的静态化检查操作、运行单元测试并使用 Codecov 生成代码覆盖率报告，部署到Netlify，并且根据Dockerfile生成Docker镜像。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// main.go的代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/astaxie/beego"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MainController <span class="keyword">struct</span> &#123;</span><br><span class="line">	beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MainController)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</span><br><span class="line">	controller.Ctx.WriteString(<span class="string">"感谢欧阳老板给我机会，尽管老板你姓欧"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	beego.Router(<span class="string">"/"</span>, &amp;MainController&#123;&#125;)</span><br><span class="line">	beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单测不知道该写什么，创建了hello的文件夹，在里面写了个最长前缀匹配的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello.go的代码</span></span><br><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// longestCommonPrefix LeetCode最长公共前缀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LongestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(strs) &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	prefix := strs[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _,k := <span class="keyword">range</span> strs &#123;</span><br><span class="line">		<span class="keyword">for</span> strings.Index(k,prefix) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(prefix) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">			&#125;</span><br><span class="line">			prefix = prefix[:<span class="built_in">len</span>(prefix) - <span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> prefix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello_test.go的代码</span></span><br><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">	. <span class="string">"github.com/smartystreets/goconvey/convey"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//TestLongestCommonPrefix goconvey单测</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLongestCommonPrefix</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	Convey(<span class="string">"TestLongestCommonPrefix should return fl "</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		a := []<span class="keyword">string</span>&#123;<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>&#125;</span><br><span class="line">		So(LongestCommonPrefix(a), ShouldEqual, <span class="string">"fl"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	Convey(<span class="string">"TestLongestCommonPrefix should return empty string "</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		b := []<span class="keyword">string</span>&#123;<span class="string">"dog"</span>, <span class="string">"racecar"</span>, <span class="string">"car"</span>&#125;</span><br><span class="line">		So(LongestCommonPrefix(b), ShouldEqual, <span class="string">""</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我一直使用<code>go modules</code>,生成依赖，最终的目录结构是下面这样的;我不太会写Makefile，所以直接就把Dockerfile放在了根目录下面。</p>
<p>.<br>└── actions-go-demo<br>    ├── Dockerfile<br>    ├── LICENSE<br>    ├── README.md<br>    ├── go.mod<br>    ├── go.sum<br>    ├── hello<br>    │   ├── hello.go<br>    │   └── hello_test.go<br>    └── main.go</p>
<h2 id="Github-Action配置"><a href="#Github-Action配置" class="headerlink" title="Github Action配置"></a>Github Action配置</h2><h3 id="简单的构建"><a href="#简单的构建" class="headerlink" title="简单的构建"></a>简单的构建</h3><p>手写或者自动生成actions的配置文件<code>.github/workflows/go.yml</code>都可以。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name: Beego</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: [ master ]</span><br><span class="line"></span><br><span class="line">env:</span><br><span class="line">  GOPROXY: "https://goproxy.cn"</span><br><span class="line">  GO111MODULE: "on"</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line"></span><br><span class="line">  build:</span><br><span class="line">    name: Build</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line"></span><br><span class="line">    - name: Set up Go 1.14</span><br><span class="line">      uses: actions/setup-go@v2</span><br><span class="line">      with:</span><br><span class="line">        go-version: ^1.14</span><br><span class="line">      id: go</span><br><span class="line"></span><br><span class="line">    - name: Check out code into the Go module directory</span><br><span class="line">      uses: actions/checkout@v2</span><br><span class="line"></span><br><span class="line">    - name: Cache Primes</span><br><span class="line">      uses: actions/cache@v1</span><br><span class="line">      with:</span><br><span class="line">        path: ~/go/pkg/mod</span><br><span class="line">        key: $&#123;&#123; runner.os &#125;&#125;-go-$&#123;&#123; hashFiles('**/go.sum') &#125;&#125;</span><br><span class="line">        restore-keys: |</span><br><span class="line">          $&#123;&#123; runner.os &#125;&#125;-go-</span><br><span class="line"></span><br><span class="line">    - name: Go Get dependencies and go module</span><br><span class="line">      run: |</span><br><span class="line">        go mod tidy</span><br><span class="line">        go get -v -t -d ./...</span><br><span class="line"></span><br><span class="line">    - name: Build</span><br><span class="line">      # 这里build 时交叉编译并设置使用所有内置库静态编译程序</span><br><span class="line">      # 方便最后一步做出的Docker镜像小一些</span><br><span class="line">      run: CGO_ENABLED=0 GOOS=linux go build -a -ldflags '-extldflags "-static"' -o main .</span><br><span class="line"></span><br><span class="line">    - name: Staticcheck</span><br><span class="line">      run: |</span><br><span class="line">        # https://github.com/actions/setup-go/issues/14</span><br><span class="line">        # 已经修复这个问题，直接go get 就行</span><br><span class="line">        # export PATH=$&#123;PATH&#125;:`go env GOPATH`/bin</span><br><span class="line">        go get -u honnef.co/go/tools/cmd/staticcheck</span><br><span class="line">        staticcheck ./...</span><br><span class="line"></span><br><span class="line">    - name: Test</span><br><span class="line">      run: |</span><br><span class="line">        go get -u github.com/smartystreets/goconvey</span><br><span class="line">        go test -v ./...</span><br><span class="line"></span><br><span class="line">    - name: Netlify deploy</span><br><span class="line">      env:</span><br><span class="line">        NETLIFY_TOKEN: $&#123;&#123; secrets.NETLIFY_TOKEN &#125;&#125;</span><br><span class="line">      run: |</span><br><span class="line">        ./netlifyctl -A $&#123;NETLIFY_TOKEN&#125; deploy || true</span><br><span class="line">        cat netlifyctl-debug.log || true</span><br><span class="line"></span><br><span class="line">     - name: Build the Docker image</span><br><span class="line">      run: |</span><br><span class="line">        docker login --username=$&#123;&#123; secrets.DOCKER_USN &#125;&#125; registry.ap-northeast-1.aliyuncs.com --password=$&#123;&#123; secrets.DOCKER_PWD &#125;&#125;</span><br><span class="line">        docker build -t beego:latest . #执行构建</span><br><span class="line">        docker tag beego registry.ap-northeast-1.aliyuncs.com/example/beego</span><br><span class="line">        docker push registry.ap-northeast-1.aliyuncs.com/example/beego:latest # 推送</span><br></pre></td></tr></table></figure>


<h3 id="Actions解析"><a href="#Actions解析" class="headerlink" title="Actions解析"></a>Actions解析</h3><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>现在使用的Go版本基本都在1.13以上，完全可以使用GoProxy，当然相对Github来说并不需要，完全可以不用设置这个环境变量。使用Go Module 来管理依赖，设置GO111MODULE为开启状态。</p>
<h4 id="设置缓存"><a href="#设置缓存" class="headerlink" title="设置缓存"></a>设置缓存</h4><p>即使使用Go Module，每次重新下载每个构建的依赖关系是真的浪费。Actions官方提供了一个缓存方式，也比较完备的说明了怎么使用，<a href="https://github.com/actions/cache" target="_blank" rel="noopener">具体移步这里</a>.</p>
<h4 id="Go-Build"><a href="#Go-Build" class="headerlink" title="Go Build"></a>Go Build</h4><p>使用交叉编译，并设置使用所有内置库静态编译程序，这样主要是为了下一步生成Docker镜像比较小。</p>
<h4 id="静态检查"><a href="#静态检查" class="headerlink" title="静态检查"></a>静态检查</h4><p>个人比较倾向于使用Staticcheck进行静态检查，如果同用使用这个就会出现构建失败的情况，国内有很多使用this 或者 self之类的语法糖，这种编译检查时候不会通过。需要去改一下名字。</p>
<h4 id="推送到阿里云"><a href="#推送到阿里云" class="headerlink" title="推送到阿里云"></a>推送到阿里云</h4><p>由于阿里云开始商业化，dockerhub与github又是无缝对接，直接吧编译好的文件推送到github上即可。我的仓库中删除了这部分。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>上述代码与配置均推送至我的github仓库，<a href="https://github.com/yangfan16/actions-go-demo" target="_blank" rel="noopener">可以在这里查看</a>。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>美国十年签证申请总结</title>
    <url>/travel/apply-us-visa/</url>
    <content><![CDATA[<blockquote>
<p>很久以来，我一直有三个愿望，名校，出国，名企。 现在正一步步实现自己的这三个愿望,出国首站就选择了美帝，现在想来无疑是作大死，当然，最终签证没能办下来。</p>
</blockquote>
<p>去年的时候女友终于毕业了，再加上刚工作，一直想要出国去看看更大的世界，恰好16年12月的时候朋友告诉我飞猪上17年五一 北京直飞三藩的来回机票双人只需要7000多大洋，一时头脑冲动就买了，在朋友的提醒下也购买了拒签险，最终准备也不是很充分，也因为一些其他客观原因，最终没有将美帝签证拿到手，把过程记录下来，自己以后再申请也罢，给别人参考也行。</p>
<a id="more"></a>

<blockquote>
<p>Ps: 这是我17年3月写的,18年7月迁移到我的博客，离本文记录时间已经过去了一段时间，请谨慎参考。</p>
</blockquote>
<h2 id="申请预约过程"><a href="#申请预约过程" class="headerlink" title="申请预约过程"></a>申请预约过程</h2><p>美国签证可以选择自己办理，也可以交给第三方旅行社，但实际上他们也就是帮你去交个钱，翻译下DS-160表格和一些旅行模板，如果自己有中信银行储蓄卡的话完全可以自己来，具体流程如下：</p>
<p>美帝签证官网地址：<a href="http://www.ustraveldocs.com/cn_zh/cn-niv-visaapply.asp" target="_blank" rel="noopener">http://www.ustraveldocs.com/cn_zh/cn-niv-visaapply.asp</a></p>
<p>填写DS-160表格  需要先准备好上传一张2寸的正方形的签证照片，系统会自动验证照片是否符合规格,填写基本账号信息完毕之后，进入冗长的详细资料填写阶段。前后大概七八页，从基本资料，工作经历，教育经历，出境经历，旅途行程安排，犯罪违法情况都需要填写。对了，都是英文！</p>
<p>行程酒店安排可以提前在Google, Booking 或者Airbnb 上预定选择你要去的美帝城市酒店，填酒店上面的英文联络方式就好了，最好自己在填写表格之前先写一份比较详尽的旅行路线规划，反正到时候面试你也是需要这个的。</p>
<p>填写完表格之后，会生成一个有唯一编号的DS-160表格，然后再缴费预约面试时间、地点。一开始会让你选择你要选择面签的城市，中国地区有北京、上海、广州、成都、香港等地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ps:不仅得把自己过去的学校、公司的名称、地址中英文都得翻译一遍，还得把准备第一次去美国的行程、入住酒店的信息和联络方式都填写一遍</span><br><span class="line">pps:填写表格，网站有超时限制，过长时间没填完，就会登出，随时点击sava保存当前表格是王道</span><br><span class="line">ppps: 不要选错面试城市，否则会非常麻烦</span><br></pre></td></tr></table></figure>

<p>如果这个做完了，基本网上预约部分就完成了，我花了一天时间，非常详尽的翻译了两个人的信息，然后飞快的在网上填写，然后填完一个人的信息之后放弃了，因为美签在线支付费用要通过中信银行借记卡，在线商城扣款, 大约160刀。 嗯， 我没有中信银行的储蓄卡，于是在飞猪上找了百程旅游帮我办理签证，一个人1298，因为两人都是护照都是白本，拒签不退款，讲真，到这个时候我是有点后悔的。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ps:网上很多信息说是旅行社的翻译非常扯淡，基本都是机翻，如果英语还好且持有中信银行借记卡又不怕麻烦的话还是可以自己申请的，百程自己说是有电话培训，结果其实就是面签前一天下午打电话通知下面试时间，以及他在哪里给我资料，什么培训都没有。当然，其实旅游签也的确不需要培训什么。</span><br></pre></td></tr></table></figure>

<h2 id="面签过程"><a href="#面签过程" class="headerlink" title="面签过程"></a>面签过程</h2><p>网上缴费后会预约面试的时间和地点，如果是第三方旅行社的话都是可以修改面试时间的。由于懒癌和其他一些原因16年一直没有预约，直到川普上台后才申请的，很神奇的预约到了3月10日，然后在朋友的催促下给旅行社打电话改到了3月1号，不幸的是川普上台后禁止一些国家人民进入美国，旅行社也说这个时间拒签风险很高，白本拒签更高，但也没什么办法了，骑虎难下啊，机票又不能改签或者退掉。</p>
<h3 id="面签准备资料"><a href="#面签准备资料" class="headerlink" title="面签准备资料"></a>面签准备资料</h3><p>1.护照<br>2.DS-160表格和面签预约单<br>3.行程单（自己做一个旧金山出发的西海岸游玩行程单）<br>4.户口本<br>5.在职和收入的中英文证明(公司HR盖公章，领导签字)<br>6.公司营业执照复印件<br>7.一年银行流水(招商银行柜台打印)<br>8.学历证明（毕业证、学位证）</p>
<h3 id="面签补充"><a href="#面签补充" class="headerlink" title="面签补充"></a>面签补充</h3><p>预约的是早上九点的，且我住的地方离亮马桥尚有一段距离，早上五点半就起床了，到了美帝领事馆之后发现预约的时间更早的人已经排起了长龙，前面有一个存包的地方，大包五十小包二十，旅行社的人就在那里把面签预约单给了我。然后就去美领馆外面排队，申请美签的人真的好多啊，而且更坑爹的不时有人从后面挤上来给说他来晚了，着急进美领馆面签，顺便踩你一两脚。三月北京的寒风像是青龙偃月刀，在冷风中瑟瑟发抖了一个小时之后终于进了美领馆。进入不得携带任何电子设备，据说腕表也不得携带，所有资料都装在一个透明的塑料文件袋中。初次安检将预约单给门口的保安，然后排队进入美领馆办公室，进入之后又过了一次安检，将外套摘了后连同资料放入一个蓝色的框子中，然后接着在里面排队。然后有工作人员扫描预约单上的条纹码，确认无误后放行，后面有两个工作人员，分别检查了DS-160表格，查看护照，并且在护照上面贴了新条纹码。接着就是排队打指纹，是美国人负责，在类似老旧的银行柜台那边，把护照贴在玻璃上指定位置，工作人员扫描了一下，第一次记录左右手四根拇指，第二次记录左右大拇指。最后排队面签。</p>
<h3 id="面签问题"><a href="#面签问题" class="headerlink" title="面签问题"></a>面签问题</h3><p>旅游签都是使用中文交流，也是那种老旧的银行柜台，工作人员在里面，我和女友一起的，面试官的声音略小，我没太听清，和女友都有点紧张，也没有说什么，我的面签官就问了下面几个问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q:你们去美国做什么？</span><br><span class="line">A:旅游  (女友答的，我有点发呆)</span><br><span class="line"></span><br><span class="line">Q:你们去哪里？</span><br><span class="line">A:旧金山 （还是女友答的，我还在持续发呆中，也没有听清）</span><br><span class="line"></span><br><span class="line">Q:把你们的结婚证给我看下</span><br><span class="line">A:嗯？？？？？（这次我们两都没听清）</span><br><span class="line">Q:结婚证</span><br><span class="line">A:我们还没结婚，是情侣。</span><br><span class="line"></span><br><span class="line">Q:有房吗？</span><br><span class="line">A:还没有房，我们刚毕业，还没有买房（我答）</span><br><span class="line"></span><br><span class="line">Q:之前去过哪里？</span><br><span class="line">A:我之前去过香港，这是我们第一次准备出国玩（我答）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q:身份证给我看下</span><br><span class="line">A:嗯？？？？？（依旧没听清）</span><br><span class="line">Q:身份证</span><br><span class="line">我们两把身份证递给了面签官</span><br><span class="line"></span><br><span class="line">然后面签官说sorry,我不能给你们签证，然后把身份证还给我们，并递给我一张白色的拒签单。整个过程面签官根本就没有看准备的那么多资料。有点沮丧。</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>办理签证之前，我还特意打电话给我们leader询问好办理吗，他们都说在北京有份很稳定的工作是非常容易的，自己也没认真做准备。面签也发挥的不好，也有朋友说最好自己单独面试，也有说因为没房没结婚的，也有说白本原因的。但结果的确是非常遗憾没能申请到美帝十年签证，但是还好的是当时购买机票时候选择购买拒签险，拒签后保险公司将机票全部进行了理赔，速度也很不错，如果以后再有机会再来一次吧。</p>
]]></content>
      <categories>
        <category>travel</category>
      </categories>
      <tags>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title>更换和重置Mac Homebrew的默认源</title>
    <url>/others/brew-remote/</url>
    <content><![CDATA[<blockquote>
<p>homewbrew最为OS X的利器，给软件的安装个更新带来了极大的便利，然而国内特殊的环境常常使得其下载更新速度极慢；我在之前切换使用阿里的镜像源，倒是便利了不少，最近发现阿里的镜像源不知道为何无法使用，又重置为默认源，谨做记录，以为后用。</p>
</blockquote>
<a id="more"></a>

<p>如果你没有更换过镜像源，执行 brew 命令安装应用的时候，跟以下 3 个仓库地址有关：</p>
<ul>
<li>brew.git</li>
<li>homebrew-core.git</li>
<li>homebrew-bottles</li>
</ul>
<h2 id="更换国内镜像源"><a href="#更换国内镜像源" class="headerlink" title="更换国内镜像源"></a>更换国内镜像源</h2><p>通过以下操作将这 3 个仓库地址全部替换为 阿里云/清华源/中科大源 提供的地址就可以使用国内的镜像源</p>
<h3 id="更换brew-git"><a href="#更换brew-git" class="headerlink" title="更换brew.git"></a>更换brew.git</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line"># 阿里云源镜像</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;homebrew&#x2F;brew.git</span><br><span class="line"># 清华镜像</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;homebrew&#x2F;brew.git</span><br><span class="line"># 中科大镜像</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;brew.git</span><br></pre></td></tr></table></figure>

<h3 id="更换homebrew-core-git"><a href="#更换homebrew-core-git" class="headerlink" title="更换homebrew-core.git"></a>更换homebrew-core.git</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;</span><br><span class="line"># 阿里云源镜像</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;homebrew&#x2F;homebrew-core.git</span><br><span class="line"># 清华镜像</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;homebrew&#x2F;homebrew-core.git</span><br><span class="line"># 中科大镜像</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-core.git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行上述命令之后，请执行 brew update 命令</p>
</blockquote>
<p>可以执行 brew config 命令，查看配置信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HOMEBREW_VERSION: 2.2.14-54-g3247f26</span><br><span class="line">ORIGIN: https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;homebrew&#x2F;brew.git</span><br><span class="line">HEAD: 3247f26a3416284cabfe0dcc28cbe05e466f622a</span><br><span class="line">Last commit: 21 minutes ago</span><br><span class="line">Core tap ORIGIN: https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;homebrew&#x2F;homebrew-core.git</span><br><span class="line">Core tap HEAD: 0d5644a597db138f3c891252bbc73eb21f720b74</span><br><span class="line">Core tap last commit: 43 minutes ago</span><br><span class="line">HOMEBREW_PREFIX: &#x2F;usr&#x2F;local</span><br><span class="line">HOMEBREW_MAKE_JOBS: 4</span><br><span class="line">CPU: quad-core 64-bit skylake</span><br><span class="line">Homebrew Ruby: 2.6.3 &#x3D;&gt;         &#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;Ruby.framework&#x2F;Versions&#x2F;2.6&#x2F;usr&#x2F;bin&#x2F;ruby</span><br><span class="line">Clang: 11.0 build 1103</span><br><span class="line">Git: 2.24.2 &#x3D;&gt; &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;usr&#x2F;bin&#x2F;git</span><br><span class="line">Curl: 7.64.1 &#x3D;&gt; &#x2F;usr&#x2F;bin&#x2F;curl</span><br><span class="line">macOS: 10.15.4-x86_64</span><br><span class="line">CLT: 11.4.1.0.1.1586360307</span><br><span class="line">Xcode: 11.4.1</span><br></pre></td></tr></table></figure>

<h3 id="更换-homebrew-bottles"><a href="#更换-homebrew-bottles" class="headerlink" title="更换 homebrew-bottles"></a>更换 homebrew-bottles</h3><p>我用的oh-my-zsh, 可以用命令<code>echo $SHELL</code> 查看自己的SHELL, 直接在<code>$HOME/.zshrc</code>文件里面增加内容或者直接在终端中运行命令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;export HOMEBREW_BOTTLE_DOMAIN&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;homebrew&#x2F;homebrew-bottles&#39; &gt;&gt; ~&#x2F;.zshrc</span><br><span class="line"></span><br><span class="line">source ~&#x2F;.zshrc</span><br></pre></td></tr></table></figure>

<p>bash 用户直接在<code>$HOME/.bash_profile</code> 文件中增加相同的内容即可。</p>
<h2 id="重置homebrew源"><a href="#重置homebrew源" class="headerlink" title="重置homebrew源"></a>重置homebrew源</h2><p>最近国内的镜像似乎并不是很好使，一大堆的404，很多也不能正常下载，我又换回使用默认的源。</p>
<h3 id="重置-brew-git"><a href="#重置-brew-git" class="headerlink" title="重置 brew.git"></a>重置 brew.git</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;brew.git</span><br></pre></td></tr></table></figure>

<h3 id="重置-homebrew-core-git"><a href="#重置-homebrew-core-git" class="headerlink" title="重置 homebrew-core.git"></a>重置 homebrew-core.git</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-core.git</span><br></pre></td></tr></table></figure>

<h3 id="重置-homebrew-bottles"><a href="#重置-homebrew-bottles" class="headerlink" title="重置 homebrew-bottles"></a>重置 homebrew-bottles</h3><p>注释掉<code>$HOME/.zshrc</code>配置文件(zsh用户)或者<code>$HOME/.bash_profile</code>配置文件(bash用户)里的有关Homebrew Bottles即可恢复官方源。 重启bash或让bash重读配置文件。 可以再次运行<code>brew config</code>查看。</p>
<h2 id="brew-cask"><a href="#brew-cask" class="headerlink" title="brew cask"></a>brew cask</h2><p>我并不使用brew cash，不过中科大的镜像里面提供了brew cask的镜像，方法与其他的并没有什么两样。重置也是使用恢复默认的github源即可。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>重学Docker之容器（二）</title>
    <url>/docker/docker-container/</url>
    <content><![CDATA[<blockquote>
<p>container是docker中最重要的，是打包代码及其所有依赖项的标准软件单元，因为container应用程序可以从一个计算环境快速可靠地运行到另一个计算环境。</p>
</blockquote>
<a id="more"></a>

<h3 id="容器的基础操作"><a href="#容器的基础操作" class="headerlink" title="容器的基础操作"></a>容器的基础操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>创建容器有两个命令可以使用<code>docker run</code> 和<code>docker create</code> ,区别在于前者创建的容器的时候还启动了容器，而后者仅仅创建了容器。</p>
<p>下图是<code>docker run</code> 的内部流程<br><img data-src="https://images.yangfan16.cn/docker-run.png" alt="docker-run流程"></p>
<p>这两个命令的参数都特别多，但总的来说用<code>docker run</code> 比较多，毕竟能够一步到位。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker create --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Create a new container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --add-host list                  Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">  -a, --attach list                    Attach to STDIN, STDOUT or STDERR</span><br><span class="line">      --blkio-weight uint16            Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)</span><br><span class="line">      --blkio-weight-device list       Block IO weight (relative device weight) (default [])</span><br><span class="line">      --cap-add list                   Add Linux capabilities</span><br><span class="line">      --cap-drop list                  Drop Linux capabilities</span><br><span class="line">      --cgroup-parent string           Optional parent cgroup for the container</span><br><span class="line">      --cidfile string                 Write the container ID to the file</span><br><span class="line">      --cpu-period int                 Limit CPU CFS (Completely Fair Scheduler) period</span><br><span class="line">      --cpu-quota int                  Limit CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line">      --cpu-rt-period int              Limit CPU real-time period in microseconds</span><br><span class="line">      --cpu-rt-runtime int             Limit CPU real-time runtime in microseconds</span><br><span class="line">  -c, --cpu-shares int                 CPU shares (relative weight)</span><br><span class="line">      --cpus decimal                   Number of CPUs</span><br><span class="line">      --cpuset-cpus string             CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --cpuset-mems string             MEMs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --device list                    Add a host device to the container</span><br><span class="line">      --device-cgroup-rule list        Add a rule to the cgroup allowed devices list</span><br><span class="line">      --device-read-bps list           Limit read rate (bytes per second) from a device (default [])</span><br><span class="line">      --device-read-iops list          Limit read rate (IO per second) from a device (default [])</span><br><span class="line">      --device-write-bps list          Limit write rate (bytes per second) to a device (default [])</span><br><span class="line">      --device-write-iops list         Limit write rate (IO per second) to a device (default [])</span><br><span class="line">      --disable-content-trust          Skip image verification (default true)</span><br><span class="line">      --dns list                       Set custom DNS servers</span><br><span class="line">      --dns-option list                Set DNS options</span><br><span class="line">      --dns-search list                Set custom DNS search domains</span><br><span class="line">      --domainname string              Container NIS domain name</span><br><span class="line">      --entrypoint string              Overwrite the default ENTRYPOINT of the image</span><br><span class="line">  -e, --env list                       Set environment variables</span><br><span class="line">      --env-file list                  Read in a file of environment variables</span><br><span class="line">      --expose list                    Expose a port or a range of ports</span><br><span class="line">      --gpus gpu-request               GPU devices to add to the container ('all' to pass all GPUs)</span><br><span class="line">      --group-add list                 Add additional groups to join</span><br><span class="line">      --health-cmd string              Command to run to check health</span><br><span class="line">      --health-interval duration       Time between running the check (ms|s|m|h) (default 0s)</span><br><span class="line">      --health-retries int             Consecutive failures needed to report unhealthy</span><br><span class="line">      --health-start-period duration   Start period for the container to initialize before starting health-retries countdown (ms|s|m|h)</span><br><span class="line">                                       (default 0s)</span><br><span class="line">      --health-timeout duration        Maximum time to allow one check to run (ms|s|m|h) (default 0s)</span><br><span class="line">      --help                           Print usage</span><br><span class="line">  -h, --hostname string                Container host name</span><br><span class="line">      --init                           Run an init inside the container that forwards signals and reaps processes</span><br><span class="line">  -i, --interactive                    Keep STDIN open even if not attached</span><br><span class="line">      --ip string                      IPv4 address (e.g., 172.30.100.104)</span><br><span class="line">      --ip6 string                     IPv6 address (e.g., 2001:db8::33)</span><br><span class="line">      --ipc string                     IPC mode to use</span><br><span class="line">      --isolation string               Container isolation technology</span><br><span class="line">      --kernel-memory bytes            Kernel memory limit</span><br><span class="line">  -l, --label list                     Set meta data on a container</span><br><span class="line">      --label-file list                Read in a line delimited file of labels</span><br><span class="line">      --link list                      Add link to another container</span><br><span class="line">      --link-local-ip list             Container IPv4/IPv6 link-local addresses</span><br><span class="line">      --log-driver string              Logging driver for the container</span><br><span class="line">      --log-opt list                   Log driver options</span><br><span class="line">      --mac-address string             Container MAC address (e.g., 92:d0:c6:0a:29:33)</span><br><span class="line">  -m, --memory bytes                   Memory limit</span><br><span class="line">      --memory-reservation bytes       Memory soft limit</span><br><span class="line">      --memory-swap bytes              Swap limit equal to memory plus swap: '-1' to enable unlimited swap</span><br><span class="line">      --memory-swappiness int          Tune container memory swappiness (0 to 100) (default -1)</span><br><span class="line">      --mount mount                    Attach a filesystem mount to the container</span><br><span class="line">      --name string                    Assign a name to the container</span><br><span class="line">      --network network                Connect a container to a network</span><br><span class="line">      --network-alias list             Add network-scoped alias for the container</span><br><span class="line">      --no-healthcheck                 Disable any container-specified HEALTHCHECK</span><br><span class="line">      --oom-kill-disable               Disable OOM Killer</span><br><span class="line">      --oom-score-adj int              Tune host's OOM preferences (-1000 to 1000)</span><br><span class="line">      --pid string                     PID namespace to use</span><br><span class="line">      --pids-limit int                 Tune container pids limit (set -1 for unlimited)</span><br><span class="line">      --platform string                Set platform if server is multi-platform capable</span><br><span class="line">      --privileged                     Give extended privileges to this container</span><br><span class="line">  -p, --publish list                   Publish a container's port(s) to the host</span><br><span class="line">  -P, --publish-all                    Publish all exposed ports to random ports</span><br><span class="line">      --read-only                      Mount the container's root filesystem as read only</span><br><span class="line">      --restart string                 Restart policy to apply when a container exits (default "no")</span><br><span class="line">      --rm                             Automatically remove the container when it exits</span><br><span class="line">      --runtime string                 Runtime to use for this container</span><br><span class="line">      --security-opt list              Security Options</span><br><span class="line">      --shm-size bytes                 Size of /dev/shm</span><br><span class="line">      --stop-signal string             Signal to stop a container (default "SIGTERM")</span><br><span class="line">      --stop-timeout int               Timeout (in seconds) to stop a container</span><br><span class="line">      --storage-opt list               Storage driver options for the container</span><br><span class="line">      --sysctl map                     Sysctl options (default map[])</span><br><span class="line">      --tmpfs list                     Mount a tmpfs directory</span><br><span class="line">  -t, --tty                            Allocate a pseudo-TTY</span><br><span class="line">      --ulimit ulimit                  Ulimit options (default [])</span><br><span class="line">  -u, --user string                    Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class="line">      --userns string                  User namespace to use</span><br><span class="line">      --uts string                     UTS namespace to use</span><br><span class="line">  -v, --volume list                    Bind mount a volume</span><br><span class="line">      --volume-driver string           Optional volume driver for the container</span><br><span class="line">      --volumes-from list              Mount volumes from the specified container(s)</span><br><span class="line">  -w, --workdir string                 Working directory inside the container</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Run a command in a new container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --add-host list                  Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">  -a, --attach list                    Attach to STDIN, STDOUT or STDERR</span><br><span class="line">      --blkio-weight uint16            Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)</span><br><span class="line">      --blkio-weight-device list       Block IO weight (relative device weight) (default [])</span><br><span class="line">      --cap-add list                   Add Linux capabilities</span><br><span class="line">      --cap-drop list                  Drop Linux capabilities</span><br><span class="line">      --cgroup-parent string           Optional parent cgroup for the container</span><br><span class="line">      --cidfile string                 Write the container ID to the file</span><br><span class="line">      --cpu-period int                 Limit CPU CFS (Completely Fair Scheduler) period</span><br><span class="line">      --cpu-quota int                  Limit CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line">      --cpu-rt-period int              Limit CPU real-time period in microseconds</span><br><span class="line">      --cpu-rt-runtime int             Limit CPU real-time runtime in microseconds</span><br><span class="line">  -c, --cpu-shares int                 CPU shares (relative weight)</span><br><span class="line">      --cpus decimal                   Number of CPUs</span><br><span class="line">      --cpuset-cpus string             CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --cpuset-mems string             MEMs in which to allow execution (0-3, 0,1)</span><br><span class="line">  -d, --detach                         Run container in background and print container ID</span><br><span class="line">      --detach-keys string             Override the key sequence for detaching a container</span><br><span class="line">      --device list                    Add a host device to the container</span><br><span class="line">      --device-cgroup-rule list        Add a rule to the cgroup allowed devices list</span><br><span class="line">      --device-read-bps list           Limit read rate (bytes per second) from a device (default [])</span><br><span class="line">      --device-read-iops list          Limit read rate (IO per second) from a device (default [])</span><br><span class="line">      --device-write-bps list          Limit write rate (bytes per second) to a device (default [])</span><br><span class="line">      --device-write-iops list         Limit write rate (IO per second) to a device (default [])</span><br><span class="line">      --disable-content-trust          Skip image verification (default true)</span><br><span class="line">      --dns list                       Set custom DNS servers</span><br><span class="line">      --dns-option list                Set DNS options</span><br><span class="line">      --dns-search list                Set custom DNS search domains</span><br><span class="line">      --domainname string              Container NIS domain name</span><br><span class="line">      --entrypoint string              Overwrite the default ENTRYPOINT of the image</span><br><span class="line">  -e, --env list                       Set environment variables</span><br><span class="line">      --env-file list                  Read in a file of environment variables</span><br><span class="line">      --expose list                    Expose a port or a range of ports</span><br><span class="line">      --gpus gpu-request               GPU devices to add to the container ('all' to pass all GPUs)</span><br><span class="line">      --group-add list                 Add additional groups to join</span><br><span class="line">      --health-cmd string              Command to run to check health</span><br><span class="line">      --health-interval duration       Time between running the check (ms|s|m|h) (default 0s)</span><br><span class="line">      --health-retries int             Consecutive failures needed to report unhealthy</span><br><span class="line">      --health-start-period duration   Start period for the container to initialize before starting health-retries countdown (ms|s|m|h)</span><br><span class="line">                                       (default 0s)</span><br><span class="line">      --health-timeout duration        Maximum time to allow one check to run (ms|s|m|h) (default 0s)</span><br><span class="line">      --help                           Print usage</span><br><span class="line">  -h, --hostname string                Container host name</span><br><span class="line">      --init                           Run an init inside the container that forwards signals and reaps processes</span><br><span class="line">  -i, --interactive                    Keep STDIN open even if not attached</span><br><span class="line">      --ip string                      IPv4 address (e.g., 172.30.100.104)</span><br><span class="line">      --ip6 string                     IPv6 address (e.g., 2001:db8::33)</span><br><span class="line">      --ipc string                     IPC mode to use</span><br><span class="line">      --isolation string               Container isolation technology</span><br><span class="line">      --kernel-memory bytes            Kernel memory limit</span><br><span class="line">  -l, --label list                     Set meta data on a container</span><br><span class="line">      --label-file list                Read in a line delimited file of labels</span><br><span class="line">      --link list                      Add link to another container</span><br><span class="line">      --link-local-ip list             Container IPv4/IPv6 link-local addresses</span><br><span class="line">      --log-driver string              Logging driver for the container</span><br><span class="line">      --log-opt list                   Log driver options</span><br><span class="line">      --mac-address string             Container MAC address (e.g., 92:d0:c6:0a:29:33)</span><br><span class="line">  -m, --memory bytes                   Memory limit</span><br><span class="line">      --memory-reservation bytes       Memory soft limit</span><br><span class="line">      --memory-swap bytes              Swap limit equal to memory plus swap: '-1' to enable unlimited swap</span><br><span class="line">      --memory-swappiness int          Tune container memory swappiness (0 to 100) (default -1)</span><br><span class="line">      --mount mount                    Attach a filesystem mount to the container</span><br><span class="line">      --name string                    Assign a name to the container</span><br><span class="line">      --network network                Connect a container to a network</span><br><span class="line">      --network-alias list             Add network-scoped alias for the container</span><br><span class="line">      --no-healthcheck                 Disable any container-specified HEALTHCHECK</span><br><span class="line">      --oom-kill-disable               Disable OOM Killer</span><br><span class="line">      --oom-score-adj int              Tune host's OOM preferences (-1000 to 1000)</span><br><span class="line">      --pid string                     PID namespace to use</span><br><span class="line">      --pids-limit int                 Tune container pids limit (set -1 for unlimited)</span><br><span class="line">      --platform string                Set platform if server is multi-platform capable</span><br><span class="line">      --privileged                     Give extended privileges to this container</span><br><span class="line">  -p, --publish list                   Publish a container's port(s) to the host</span><br><span class="line">  -P, --publish-all                    Publish all exposed ports to random ports</span><br><span class="line">      --read-only                      Mount the container's root filesystem as read only</span><br><span class="line">      --restart string                 Restart policy to apply when a container exits (default "no")</span><br><span class="line">      --rm                             Automatically remove the container when it exits</span><br><span class="line">      --runtime string                 Runtime to use for this container</span><br><span class="line">      --security-opt list              Security Options</span><br><span class="line">      --shm-size bytes                 Size of /dev/shm</span><br><span class="line">      --sig-proxy                      Proxy received signals to the process (default true)</span><br><span class="line">      --stop-signal string             Signal to stop a container (default "SIGTERM")</span><br><span class="line">      --stop-timeout int               Timeout (in seconds) to stop a container</span><br><span class="line">      --storage-opt list               Storage driver options for the container</span><br><span class="line">      --sysctl map                     Sysctl options (default map[])</span><br><span class="line">      --tmpfs list                     Mount a tmpfs directory</span><br><span class="line">  -t, --tty                            Allocate a pseudo-TTY</span><br><span class="line">      --ulimit ulimit                  Ulimit options (default [])</span><br><span class="line">  -u, --user string                    Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class="line">      --userns string                  User namespace to use</span><br><span class="line">      --uts string                     UTS namespace to use</span><br><span class="line">  -v, --volume list                    Bind mount a volume</span><br><span class="line">      --volume-driver string           Optional volume driver for the container</span><br><span class="line">      --volumes-from list              Mount volumes from the specified container(s)</span><br><span class="line">  -w, --workdir string                 Working directory inside the container</span><br></pre></td></tr></table></figure>

<p><code>docker run</code>常用的几个参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>注释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>–attach</td>
<td>终端启动容器后直接连接上容器，后面的操作都是对容器内部的操作</td>
<td>简写-a</td>
</tr>
<tr>
<td>–detach</td>
<td>后台运行容器</td>
<td>简写-d</td>
</tr>
<tr>
<td>–interactive</td>
<td>打开容器的标准输入（STDIN）</td>
<td>简写-i</td>
</tr>
<tr>
<td>–publish</td>
<td>端口映射(docker端口：宿主机端口)</td>
<td>简写-p</td>
</tr>
<tr>
<td>–tty</td>
<td>为容器建立一个命令行终端</td>
<td>简写-t</td>
</tr>
<tr>
<td>—-volume</td>
<td>绑定一个卷(数据卷或者网络卷)</td>
<td>简写-v</td>
</tr>
<tr>
<td>–restart</td>
<td>检查容器的退出码，并据 此来决定是否需要重启容器</td>
<td>–restart标志被设置成always。不管容器的返回码是什么，Docker都会尝试 重启容器。也可以将其设置成on-failure，还能设置为–restart=on-failure:5（当收到一个非0的返回码时，最多尝试重启容器5次）</td>
</tr>
<tr>
<td>–rm</td>
<td>退出容器的时候自动删除</td>
<td></td>
</tr>
<tr>
<td>–name</td>
<td>给容器起一个温暖的名字:)</td>
<td></td>
</tr>
</tbody></table>
<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p><code>docker ps</code>即可查看容器,这个参数不多，也都很简单。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker ps --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker ps [OPTIONS]</span><br><span class="line"></span><br><span class="line">List containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Show all containers (default shows just running)</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print containers using a Go template</span><br><span class="line">  -n, --last int        Show n last created containers (includes all states) (default -1)</span><br><span class="line">  -l, --latest          Show the latest created container (includes all states)</span><br><span class="line">      --no-trunc        Don't truncate output</span><br><span class="line">  -q, --quiet           Only display numeric IDs</span><br><span class="line">  -s, --size            Display total file sizes</span><br></pre></td></tr></table></figure>

<p>简单介绍一下其结果的含义：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CONTAINER ID</td>
<td>容器唯一标识ID(一个64位的十六进制数,一般只显示前面的12位)</td>
</tr>
<tr>
<td>IMAGE</td>
<td>创建容器时使用的镜像</td>
</tr>
<tr>
<td>COMMAND</td>
<td>容器最后运行的命令</td>
</tr>
<tr>
<td>CREATED</td>
<td>创建容器的时间</td>
</tr>
<tr>
<td>STATUS</td>
<td>容器状态 运行状态为UP 和已经运行时间；停止状态是类似Exited(错误码)的形式，错误码中0是正常退出。可以在dashboard中查看log</td>
</tr>
<tr>
<td>PORTS</td>
<td>对外开放的端口</td>
</tr>
<tr>
<td>NAMES</td>
<td>容器名,同一台宿主主机上不允许有同名的容器存在</td>
</tr>
</tbody></table>
<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>启动容器同样可以使用三个命令，<code>docker run</code>和<code>docker start</code> 以及<code>docker restart</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker start --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Start one or more stopped containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --attach                  Attach STDOUT/STDERR and forward signals</span><br><span class="line">      --checkpoint string       Restore from this checkpoint</span><br><span class="line">      --checkpoint-dir string   Use a custom checkpoint storage directory</span><br><span class="line">      --detach-keys string      Override the key sequence for detaching a container</span><br><span class="line">  -i, --interactive             Attach container's STDIN</span><br><span class="line">  </span><br><span class="line"><span class="meta">$</span><span class="bash"> docker restart --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Restart one or more containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -t, --time int   Seconds to wait for stop before killing the container (default 10)</span><br></pre></td></tr></table></figure>



<h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><p>停止容器主要是<code>docker stop</code>和<code>docker kill</code>,交互型容器还可以在shell中输 入exit，或者是使用ctrl+d组合键来使其退出。<br><code>docker stop</code>命令给容器中的进程发送SIGTERM信号，默认行为是会导致容器退出。<code>docker kill</code>会给容器的进程发送SIGKILL信号，该信号将会使容器必然退出。</p>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p><code>docker rm</code> 可以删除容器，停止容器只是现在不用了，但这个东西还在。经常会出现组合式测docker 命令，比如说一次删除所有容器<code>docker rm &quot;docker ps -a -q&quot;</code></p>
<h3 id="容器内信息的获取"><a href="#容器内信息的获取" class="headerlink" title="容器内信息的获取"></a>容器内信息的获取</h3><h4 id="依附容器"><a href="#依附容器" class="headerlink" title="依附容器"></a>依附容器</h4><p>可交互的容器创建后，可以通过attach命令来将终端依附到容器上<code>docker attach</code> 使用之后需要多按一次回车。</p>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>Docker给提供了logs、inspect等方法。docker logs命令用于查看容器的日志，它将输出到标准输出的数据作为日志输出到运行docker logs命令的终端上。 -f 参数可以一直看日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker logs --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Fetch the logs of a container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow log output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)</span><br><span class="line">      --tail string    Number of lines to show from the end of the logs (default "all")</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)</span><br></pre></td></tr></table></figure>

<h4 id="查看容器进程"><a href="#查看容器进程" class="headerlink" title="查看容器进程"></a>查看容器进程</h4><p><code>docker top</code>可以查看容器中的进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker top --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker top CONTAINER [ps OPTIONS]</span><br><span class="line"></span><br><span class="line">Display the running processes of a container</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker top 48edbbc56ccb</span></span><br><span class="line">PID                 USER                TIME                COMMAND</span><br><span class="line">3909                999                 0:20                redis-server *:6379</span><br></pre></td></tr></table></figure>

<h4 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h4><p><code>docker inspect</code> 用于查看容器的配置信息，包含容器名、环境变量、运行命令、主机配置、 网络配置和数据卷配置等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker inspect --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br><span class="line"></span><br><span class="line">Return low-level information on Docker objects</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --format string   Format the output using the given Go template</span><br><span class="line">  -s, --size            Display total file sizes if the type is container</span><br><span class="line">      --type string     Return JSON for specified type</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="meta">$</span><span class="bash"> docker inspect 48edbbc56ccb | head</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "Id": "48edbbc56ccb13bb265d805f0fd0660d6f0d5004aa8eea5eb71b61074e997247",</span><br><span class="line">        "Created": "2020-05-05T07:47:19.328346867Z",</span><br><span class="line">        "Path": "docker-entrypoint.sh",</span><br><span class="line">        "Args": [</span><br><span class="line">            "redis-server"</span><br><span class="line">        ],</span><br><span class="line">        "State": &#123;</span><br><span class="line">            "Status": "running",</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器运行状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker inspect --format=<span class="string">'&#123;&#123; .State.Running &#125;&#125;'</span> 48edbbc56ccb</span></span><br><span class="line">true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器IP</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker inspect --format <span class="string">'&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;'</span> 48edbbc56ccb</span></span><br><span class="line">172.17.0.2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器名和运行状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker inspect --format <span class="string">'&#123;&#123;.Name&#125;&#125; &#123;&#123;.State.Running&#125;&#125;'</span> 48edbbc56ccb</span></span><br><span class="line">/musing_cori true</span><br></pre></td></tr></table></figure>

<h4 id="容器内执行命令"><a href="#容器内执行命令" class="headerlink" title="容器内执行命令"></a>容器内执行命令</h4><p><code>docker exec</code>命令在容器中运行新的任务，它可以创建两种任务：后台型任务和交互型任务。后台型任务没有用户交互终端，交互型任务具 有和用户交互的输入输出终端。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line"></span><br><span class="line">Run a command in a running container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -d, --detach               Detached mode: run command in the background</span><br><span class="line">      --detach-keys string   Override the key sequence for detaching a container</span><br><span class="line">  -e, --env list             Set environment variables</span><br><span class="line">  -i, --interactive          Keep STDIN open even if not attached</span><br><span class="line">      --privileged           Give extended privileges to the command</span><br><span class="line">  -t, --tty                  Allocate a pseudo-TTY</span><br><span class="line">  -u, --user string          Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class="line">  -w, --workdir string       Working directory inside the container</span><br></pre></td></tr></table></figure>

<h4 id="清理容器"><a href="#清理容器" class="headerlink" title="清理容器"></a>清理容器</h4><p><code>docker container prune</code> 清理所有处于终止状态的容器<br><code>docker system prune</code> docker 使用久了，可以使用这个命令来清理一下空间,会清楚不适用的数据。可以使用<code>docker system df</code>查看使用的磁盘空间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker system df</span></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              10                  0                   1.772GB             1.772GB (100%)</span><br><span class="line">Containers          0                   0                   0B                  0B</span><br><span class="line">Local Volumes       1                   0                   92B                 92B (100%)</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure>

<h3 id="容器的导入和导出"><a href="#容器的导入和导出" class="headerlink" title="容器的导入和导出"></a>容器的导入和导出</h3><p>docker提供了这两个命令，但是并不常用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">export</span> --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker export [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Export a container's filesystem as a tar archive</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -o, --output string   Write to a file, instead of STDOUT</span><br><span class="line">  </span><br><span class="line"><span class="meta">$</span><span class="bash"> docker import --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">Import the contents from a tarball to create a filesystem image</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -c, --change list       Apply Dockerfile instruction to the created image</span><br><span class="line">  -m, --message string    Set commit message for imported image</span><br><span class="line">      --platform string   Set platform if server is multi-platform capable</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>重学Docker之镜像（一）</title>
    <url>/docker/docker-images/</url>
    <content><![CDATA[<blockquote>
<p>在写完podman体验的文章后，有几个朋友说作为开发还没开始使用Docker，就要去Docker,这世界变化太快。回过头想重新看一下Docker的使用，也体验一下最近docker带来的新的改变。谨做系列文章以记。</p>
</blockquote>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker的安装现在已经非常的简单，不管是Mac Windows还是Linux得各种发行版本，也都默认就带了docker-compose<br>这样的单机容器编排工具和kubernetes。 我的实验环境如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OS: macOS Catalina 1.15.4</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker version</span></span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           19.03.8</span><br><span class="line"> API version:       1.40</span><br><span class="line"> Go version:        go1.12.17</span><br><span class="line"> Git commit:        afacb8b</span><br><span class="line"> Built:             Wed Mar 11 01:21:11 2020</span><br><span class="line"> OS/Arch:           darwin/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          19.03.8</span><br><span class="line">  API version:      1.40 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.12.17</span><br><span class="line">  Git commit:       afacb8b</span><br><span class="line">  Built:            Wed Mar 11 01:29:16 2020</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     true</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          v1.2.13</span><br><span class="line">  GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.0-rc10</span><br><span class="line">  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.18.0</span><br><span class="line">  GitCommit:        fec3683</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose -v</span></span><br><span class="line">docker-compose version 1.25.4, build 8d51620a</span><br></pre></td></tr></table></figure>

<h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>可以使用阿里云的镜像加速，我不喜欢，更多地时候我是使用科学上网。<code>export http_proxy=xxx</code>就可以</p>
<h2 id="镜像概念"><a href="#镜像概念" class="headerlink" title="镜像概念"></a>镜像概念</h2><p>镜像是一个包含程序运行的必要依赖环境和代码的只读文件，采用分层的文件系统，将每一次改变以读写层的形式增加到原来的制度文件上。</p>
<h2 id="镜像与容器的联系"><a href="#镜像与容器的联系" class="headerlink" title="镜像与容器的联系"></a>镜像与容器的联系</h2><p>镜像是容器运行的基石。<br><img data-src="https://images.yangfan16.cn/docker-image-container.jpeg" alt="结构示意图"></p>
<p>容器 = 容器镜像 + 可读可写层<br><img data-src="https://images.yangfan16.cn/container-images.png" alt="平面示意图"></p>
<h2 id="镜像的管理"><a href="#镜像的管理" class="headerlink" title="镜像的管理"></a>镜像的管理</h2><h3 id="镜像查看"><a href="#镜像查看" class="headerlink" title="镜像查看"></a>镜像查看</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker images</span></span><br><span class="line">REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">getting-started                      latest              a1d482020cca        3 hours ago         142MB</span><br><span class="line">node                                 latest              a511eb5c14ec        4 days ago          941MB</span><br><span class="line">node                                 12-alpine           7a48db49edbf        6 days ago          88.7MB</span><br><span class="line">docker/getting-started               latest              3c156928aeec        2 weeks ago         24.8MB</span><br><span class="line">k8s.gcr.io/kube-proxy                v1.15.5             cbd7f21fec99        6 months ago        82.4MB</span><br><span class="line">k8s.gcr.io/kube-controller-manager   v1.15.5             1399a72fa1a9        6 months ago        159MB</span><br><span class="line">k8s.gcr.io/kube-apiserver            v1.15.5             e534b1952a0d        6 months ago        207MB</span><br><span class="line">k8s.gcr.io/kube-scheduler            v1.15.5             fab2dded59dd        6 months ago        81.1MB</span><br><span class="line">k8s.gcr.io/coredns                   1.3.1               eb516548c180        15 months ago       40.3MB</span><br><span class="line">k8s.gcr.io/etcd                      3.3.10              2c4adeb21b4f        17 months ago       258MB</span><br><span class="line">k8s.gcr.io/pause                     3.1                 da86e6ba6ca1        2 years ago         742kB</span><br></pre></td></tr></table></figure>

<h3 id="下载和删除镜像"><a href="#下载和删除镜像" class="headerlink" title="下载和删除镜像"></a>下载和删除镜像</h3><p>可以<code>docker pull</code> 也可以<code>docker run</code>(不存在就会下载)。 下载之前还可以运行<code>docker search</code>查看一下。 删除镜像使用<code>docker rmi</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line"></span><br><span class="line">Pull an image or a repository from a registry</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all-tags                Download all tagged images in the repository</span><br><span class="line">      --disable-content-trust   Skip image verification (default true)</span><br><span class="line">      --platform string         Set platform if server is multi-platform capable</span><br><span class="line">  -q, --quiet                   Suppress verbose output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker pull redis:latest</span></span><br><span class="line">latest: Pulling from library/redis</span><br><span class="line">54fec2fa59d0: Pull complete</span><br><span class="line">9c94e11103d9: Pull complete</span><br><span class="line">04ab1bfc453f: Pull complete</span><br><span class="line">a22fde870392: Pull complete</span><br><span class="line">def16cac9f02: Pull complete</span><br><span class="line">1604f5999542: Pull complete</span><br><span class="line">Digest: sha256:f7ee67d8d9050357a6ea362e2a7e8b65a6823d9b612bc430d057416788ef6df9</span><br><span class="line">Status: Downloaded newer image for redis:latest</span><br><span class="line">docker.io/library/redis:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除后使用docker pull</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rmi redis</span></span><br><span class="line">Untagged: redis:latest</span><br><span class="line">Untagged: redis@sha256:f7ee67d8d9050357a6ea362e2a7e8b65a6823d9b612bc430d057416788ef6df9</span><br><span class="line">Deleted: sha256:f9b9909726890b00d2098081642edf32e5211b7ab53563929a47f250bcdc1d7c</span><br><span class="line">Deleted: sha256:7bd7286c61dee81eb691f022d070202ba2840574c460f6dcbc21792f8bf22a7f</span><br><span class="line">Deleted: sha256:ba618723adf8eb28ec3d2b2003442599e3f947b4d66875b80dc6582c61f89a27</span><br><span class="line">Deleted: sha256:cd3c331f934414f0d7a2a3ceb80935a54252dba553f1c1ee823961a07e8d1957</span><br><span class="line">Deleted: sha256:09f9b5d7722b181ae2acd61396c20549afdea66ee31f921850191db5afe6738a</span><br><span class="line">Deleted: sha256:3bd2921d0d3dd52dbcdc462f35b11cb89df901205284b0fea03c19bb8359907a</span><br><span class="line">Deleted: sha256:c2adabaecedbda0af72b153c6499a0555f3a769d52370469d8f6bd6328af9b13</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以查看一下是否删除了</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker images</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数p 指映射端口[docker端口：宿主机端口] 参数d 指以daemon方式运行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -dp 6379:6379 redis:latest</span></span><br><span class="line">Unable to find image 'redis:latest' locally</span><br><span class="line">latest: Pulling from library/redis</span><br><span class="line">54fec2fa59d0: Pull complete</span><br><span class="line">9c94e11103d9: Pull complete</span><br><span class="line">04ab1bfc453f: Pull complete</span><br><span class="line">a22fde870392: Pull complete</span><br><span class="line">def16cac9f02: Pull complete</span><br><span class="line">1604f5999542: Pull complete</span><br><span class="line">Digest: sha256:f7ee67d8d9050357a6ea362e2a7e8b65a6823d9b612bc430d057416788ef6df9</span><br><span class="line">Status: Downloaded newer image for redis:latest</span><br><span class="line">48edbbc56ccb13bb265d805f0fd0660d6f0d5004aa8eea5eb71b61074e997247</span><br></pre></td></tr></table></figure>

<h3 id="创建本地镜像"><a href="#创建本地镜像" class="headerlink" title="创建本地镜像"></a>创建本地镜像</h3><h4 id="Dockerfile创建镜像"><a href="#Dockerfile创建镜像" class="headerlink" title="Dockerfile创建镜像"></a>Dockerfile创建镜像</h4><p>将需要对镜像进行的操作全部 写到一个文件中，然后使用docker build 命令从这个文件中创建镜像。这种方法可以使镜像的创 建变得透明和独立化， 并且创建过程可以被重复执行。 Dockerfile文件以行为单位， 行首为 Dockerfile命令，命令都是大写形式，其后紧跟着的是命令的参数。</p>
<p>具体可以参看后续的Dockerfile笔记。</p>
<h2 id="镜像分发"><a href="#镜像分发" class="headerlink" title="镜像分发"></a>镜像分发</h2><p>将自己打包好的镜像可以推送到dockerhub或者阿里云镜像中心，亦或者是私人的镜像仓库都可以。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker push --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:	docker push [OPTIONS] NAME[:TAG]</span><br><span class="line"></span><br><span class="line">Push an image or a repository to a registry</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --disable-content-trust   Skip image signing (default true)</span><br></pre></td></tr></table></figure>

<h2 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h2><p>除了在本地创建镜像然后使用push命令将其推送到DockerHub之外，可以使用DockerHub(阿里云也提供了)提供的自动化构建技术在服务端直接构建镜像。一个包含Dockerfile 文件的Git Hub或Bit Bucket的仓库，Docker Hub的构建集群服务器就会自动构建镜像。通过这种 方式构建出来的镜像会被标记为Automated Build，也可以称为受信构建（Trusted Build）。</p>
<p>自动化构建的优点在于：</p>
<ul>
<li>用户可以确保他拉取的镜像是使用特定方式构建出来的。</li>
<li>访问你的Docker Hub的用户能够自由查阅Dockerfile文件。</li>
<li>因为构建的过程是自动的，所以能确保仓库里的镜像都是最新的。</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现通用网络连接池</title>
    <url>/go/go-conns-pool/</url>
    <content><![CDATA[<blockquote>
<p>连接池在羡慕开发中是经常见到的，因为TCP的三次握手等原因，建立一个连接算是一个比较高的开销，而频繁的创建和销毁连接会带来严重的性能下降，所以在一个需要多次与特定实体交互的程序中，就需要维持一个连接池，里面有可以复用的连接可供重复使用。</p>
</blockquote>
<blockquote>
<p>PS: 今天在面试中被要求手写一个通用连接池，紧张之下表现的一塌糊涂，回来之后查缺补漏，增补记录以作后续提成</p>
</blockquote>
<a id="more"></a>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="什么是连接池"><a href="#什么是连接池" class="headerlink" title="什么是连接池"></a>什么是连接池</h3><ul>
<li>顾名思义是一个池子</li>
<li>池子里面存放有限数量即时可用的连接，减少创建连接和关闭连接的时间</li>
<li>连接是有存活时间的</li>
</ul>
<p>以数据库连接池为例，可以简单画一张流程图表示连接池的生命周期：</p>
<p><img data-src="https://images.yangfan16.cn/%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F.jpg" alt="连接池的生命周期"></p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>gorm是复用database/sql的连接池,redigo是自己维护了一个连接池,<a href="https://github.com/gomodule/redigo/blob/master/redis/pool.go" target="_blank" rel="noopener">代码参考这里</a>。实现一个通用的网络连接池，连接池的实现不依赖具体的实例，而依赖一个接口，只要实现了接口的对象都可以被池管理。<br>Ps: 实现基于<code>interface{}</code>的连接池，这样任何对象都可以被池管理。</p>
<h3 id="功能与要求"><a href="#功能与要求" class="headerlink" title="功能与要求"></a>功能与要求</h3><ul>
<li>线程安全 thread safe </li>
<li>获取连接，释放连接</li>
<li>连接池中连接类型为interface{}，使得更加通用</li>
<li>支撑连接的最大空闲时间，超时的连接将关闭丢弃，可避免空闲时连接自动失效问题</li>
<li>设置最大连接数，连接池的容量，连接存活时间等等</li>
<li>支持用户设定ping方法，检查连接的连通性，无效的连接将丢弃</li>
<li>使用channel处理池中的连接，高效</li>
</ul>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><ul>
<li>确定连接池的属性: 如最大连接数、容量、连接创建时间和存活时间</li>
<li>拟使用连接池以及超过最大连接数后等待其他连接释放</li>
<li>保证在多协程操作下数据的一致性</li>
<li>最好实现连接的超时监听和通知</li>
</ul>
<h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><p> gorm复用的是<code>database/sql连接池</code>,redigo维护了一个自己的连接池，但是两者的实现都很复杂，移植代码的成本过高。fatih大神有一个<code>pool</code>库，<a href="https://github.com/fatih/pool/tree/v3.0.0" target="_blank" rel="noopener">具体移步这里</a>，遗憾的是该项目目前已经不再维护，<a href="https://pkg.go.dev/mod/gopkg.in/fatih/pool.v3" target="_blank" rel="noopener">具体文档在此</a>。最后一个版本也没有实现主动检查连接超时、MaxIdle配置，还有MaxConn，算是一个半成品，就基于fatih大神的这个库进行再次开发</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="定义Pool-interface"><a href="#定义Pool-interface" class="headerlink" title="定义Pool interface"></a>定义Pool interface</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Get 从连接池中获取一个连接</span></span><br><span class="line">	Get() (<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">	<span class="comment">// Put 连接放回连接池中</span></span><br><span class="line">	Put(<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	<span class="comment">// Close 关闭连接</span></span><br><span class="line">	Close(<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	<span class="comment">// Release 释放连接池中的所有连接</span></span><br><span class="line">	Release()</span><br><span class="line">	<span class="comment">// Len 查看当前连接迟中的连接数量</span></span><br><span class="line">	Len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="定义连接池相关配置"><a href="#定义连接池相关配置" class="headerlink" title="定义连接池相关配置"></a>定义连接池相关配置</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	InitialCap  <span class="keyword">int</span>                         <span class="comment">//连接池中的最小连接数</span></span><br><span class="line">	MaxCap      <span class="keyword">int</span>                         <span class="comment">//最大的并发存活连接数</span></span><br><span class="line">	MaxIdle     <span class="keyword">int</span>                         <span class="comment">//最大存活连接数</span></span><br><span class="line">	Factory     <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span> //生成连接的方法</span></span><br><span class="line">	Close       <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>     //关闭连接的方法</span></span><br><span class="line">	Ping        <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>     //检查连接是否有效的方法</span></span><br><span class="line">	IdleTimeout time.Duration               <span class="comment">//连接最大空闲时间，超过该时间则连接失效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p> 将连接句柄放入channel中，由于缓冲channel的特性，获取连接时，如果连接池中满足直接返回连接的情况时将直接返回，否则将阻塞等待或者直接创建新的连接，因此需要定义通用连接:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> idleConn <span class="keyword">struct</span> &#123;</span><br><span class="line">	conn <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	t    time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> connReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	idleConnect *idleConn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GenericPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> GenericPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu                 sync.RWMutex                <span class="comment">//锁</span></span><br><span class="line">	connections        <span class="keyword">chan</span> *idleConn              <span class="comment">//channel 为包装后的类型，包含连接和时间</span></span><br><span class="line">	factory            <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span> //创建连接的方法</span></span><br><span class="line">	<span class="built_in">close</span>              <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>     //关闭连接的方法</span></span><br><span class="line">	ping               <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>     //检查连接的放大</span></span><br><span class="line">	idleTimeout        time.Duration               <span class="comment">//连接最大空闲时间</span></span><br><span class="line">	waitTimeout        time.Duration               <span class="comment">//等待超时时间</span></span><br><span class="line">	maxActive          <span class="keyword">int</span>                         <span class="comment">//最大存活连接数</span></span><br><span class="line">	openingConnections <span class="keyword">int</span></span><br><span class="line">	connRequests       []<span class="keyword">chan</span> connReq</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单包装了一些，在fatih大神的基础上增加了连接池常用的一些属性</p>
<h3 id="初始化连接池"><a href="#初始化连接池" class="headerlink" title="初始化连接池"></a>初始化连接池</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGenericPool</span><span class="params">(config *Config)</span> <span class="params">(Pool, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//初始容量判断</span></span><br><span class="line">	<span class="keyword">if</span> !(config.InitialCap &lt;= config.MaxIdle &amp;&amp; config.MaxCap &gt;= config.MaxIdle &amp;&amp; config.InitialCap &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"invalid capacity settings"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//必须有创建方法</span></span><br><span class="line">	<span class="keyword">if</span> config.Factory == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"invalid factory func settings"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> config.Close == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"invalid close func settings"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	genericPool := &amp;GenericPool&#123;</span><br><span class="line">		connections:        <span class="built_in">make</span>(<span class="keyword">chan</span> *idleConn, config.MaxIdle),</span><br><span class="line">		factory:            config.Factory,</span><br><span class="line">		<span class="built_in">close</span>:              config.Close,</span><br><span class="line">		idleTimeout:        config.IdleTimeout,</span><br><span class="line">		maxActive:          config.MaxCap,</span><br><span class="line">		openingConnections: config.InitialCap,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.Ping != <span class="literal">nil</span> &#123;</span><br><span class="line">		genericPool.ping = config.Ping</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; config.InitialCap; i++ &#123;</span><br><span class="line">		conn, err := genericPool.factory()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			genericPool.Release()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"factory is not able to fill the pool: %s"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		genericPool.connections &lt;- &amp;idleConn&#123;conn: conn, t: time.Now()&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> genericPool, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码很简单，基本就是常见的应用，唯一的问题就是函数签名中返回的是Pool类型，实际返回的是一个<code>genericPool</code>的实例化对象，只要实现我们之前定义的接口的方法即可。</p>
<h3 id="实现接口后的完整代码"><a href="#实现接口后的完整代码" class="headerlink" title="实现接口后的完整代码"></a>实现接口后的完整代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ErrClosed               = errors.New(<span class="string">"pool is closed"</span>)</span><br><span class="line">	ErrMaxActiveConnReached = errors.New(<span class="string">"MaxActiveConnReached"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	InitialCap  <span class="keyword">int</span>                         <span class="comment">//连接池中的最小连接数</span></span><br><span class="line">	MaxCap      <span class="keyword">int</span>                         <span class="comment">//最大的并发存活连接数</span></span><br><span class="line">	MaxIdle     <span class="keyword">int</span>                         <span class="comment">//最大存活连接数</span></span><br><span class="line">	Factory     <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span> //生成连接的方法</span></span><br><span class="line">	Close       <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>     //关闭连接的方法</span></span><br><span class="line">	Ping        <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>     //检查连接是否有效的方法</span></span><br><span class="line">	IdleTimeout time.Duration               <span class="comment">//连接最大空闲时间，超过该时间则连接失效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> idleConn <span class="keyword">struct</span> &#123;</span><br><span class="line">	conn <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	t    time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> connReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	idleConnect *idleConn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GenericPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu                 sync.RWMutex                <span class="comment">//锁</span></span><br><span class="line">	connections        <span class="keyword">chan</span> *idleConn              <span class="comment">//channel 为包装后的类型，包含连接和时间</span></span><br><span class="line">	factory            <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span> //创建连接的方法</span></span><br><span class="line">	<span class="built_in">close</span>              <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>     //关闭连接的方法</span></span><br><span class="line">	ping               <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>     //检查连接的放大</span></span><br><span class="line">	idleTimeout        time.Duration               <span class="comment">//连接最大空闲时间</span></span><br><span class="line">	waitTimeout        time.Duration               <span class="comment">//等待超时时间</span></span><br><span class="line">	maxActive          <span class="keyword">int</span>                         <span class="comment">//最大存活连接数</span></span><br><span class="line">	openingConnections <span class="keyword">int</span></span><br><span class="line">	connRequests       []<span class="keyword">chan</span> connReq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ping 检查连接状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GenericPool)</span> <span class="title">Ping</span><span class="params">(conn <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> conn == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"connection is nil. rejecting"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g.ping(conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getConnections 获取所有连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GenericPool)</span> <span class="title">getConnections</span><span class="params">()</span> <span class="title">chan</span> *<span class="title">idleConn</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> g.mu.Unlock()</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">return</span> g.connections</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GenericPool)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	connections := g.getConnections()</span><br><span class="line">	<span class="keyword">if</span> connections == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrClosed</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> wrapConn := &lt;-connections:</span><br><span class="line">			<span class="keyword">if</span> wrapConn == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, ErrClosed</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//还要判断这个链接的存活时间是否超过了最大允许存活时间</span></span><br><span class="line">			<span class="keyword">if</span> g.idleTimeout &gt; <span class="number">0</span> &amp;&amp; wrapConn.t.Add(g.idleTimeout).Before(time.Now()) &#123;</span><br><span class="line">				<span class="comment">//丢弃并关闭该连接</span></span><br><span class="line">				g.Close(wrapConn.conn)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 判断是否失效，失效则丢弃，如果用户没有设定 ping 方法，就不检查</span></span><br><span class="line">			<span class="keyword">if</span> g.ping != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err := g.Ping(wrapConn.conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="comment">//丢弃并关闭该连接</span></span><br><span class="line">					g.Close(wrapConn.conn)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> wrapConn, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			g.mu.Lock()</span><br><span class="line">			<span class="keyword">if</span> g.openingConnections &gt;= g.maxActive &#123;</span><br><span class="line">				req := <span class="built_in">make</span>(<span class="keyword">chan</span> connReq, <span class="number">1</span>)</span><br><span class="line">				g.connRequests = <span class="built_in">append</span>(g.connRequests, req)</span><br><span class="line">				<span class="comment">// 不在循环中使用defer  避免造成内存泄漏</span></span><br><span class="line">				g.mu.Unlock()</span><br><span class="line">				ret, ok := &lt;-req</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span>, ErrMaxActiveConnReached</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> g.idleTimeout &gt; <span class="number">0</span> &amp;&amp; ret.idleConnect.t.Add(g.idleTimeout).Before(time.Now()) &#123;</span><br><span class="line">					<span class="comment">//丢弃并关闭该连接</span></span><br><span class="line">					g.Close(ret.idleConnect.conn)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> ret.idleConnect.conn, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> g.factory == <span class="literal">nil</span> &#123;</span><br><span class="line">				g.mu.Unlock()</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, ErrClosed</span><br><span class="line">			&#125;</span><br><span class="line">			conn, err := g.factory()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				g.mu.Unlock()</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			g.openingConnections++</span><br><span class="line">			g.mu.Unlock()</span><br><span class="line">			<span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GenericPool)</span> <span class="title">Put</span><span class="params">(conn <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> conn == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"connection is nil. rejecting"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> g.connections == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> g.Close(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> l := <span class="built_in">len</span>(g.connRequests); l &gt; <span class="number">0</span> &#123;</span><br><span class="line">		req := g.connRequests[<span class="number">0</span>]</span><br><span class="line">		<span class="built_in">copy</span>(g.connRequests, g.connRequests[<span class="number">1</span>:])</span><br><span class="line">		g.connRequests = g.connRequests[:l<span class="number">-1</span>]</span><br><span class="line">		req &lt;- connReq&#123;</span><br><span class="line">			idleConnect: &amp;idleConn&#123;conn: conn, t: time.Now()&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> g.connections &lt;- &amp;idleConn&#123;conn: conn, t: time.Now()&#125;:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">//连接池已满，直接关闭该连接</span></span><br><span class="line">			<span class="keyword">return</span> g.Close(conn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GenericPool)</span> <span class="title">Close</span><span class="params">(conn <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> conn == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"connection is nil. rejecting"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> g.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> g.<span class="built_in">close</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	g.openingConnections--</span><br><span class="line">	<span class="keyword">return</span> g.<span class="built_in">close</span>(conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GenericPool)</span> <span class="title">Release</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> g.mu.Unlock()</span><br><span class="line">	connections := g.connections</span><br><span class="line">	g.connections = <span class="literal">nil</span></span><br><span class="line">	g.factory = <span class="literal">nil</span></span><br><span class="line">	g.ping = <span class="literal">nil</span></span><br><span class="line">	closeFun := g.<span class="built_in">close</span></span><br><span class="line">	g.<span class="built_in">close</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> connections == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(connections)</span><br><span class="line">	<span class="keyword">for</span> wrapConn := <span class="keyword">range</span> connections &#123;</span><br><span class="line">		_ = closeFun(wrapConn.conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GenericPool)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(g.getConnections())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewGenericPool 初始化连接池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGenericPool</span><span class="params">(config *Config)</span> <span class="params">(Pool, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//初始容量判断</span></span><br><span class="line">	<span class="keyword">if</span> !(config.InitialCap &lt;= config.MaxIdle &amp;&amp; config.MaxCap &gt;= config.MaxIdle &amp;&amp; config.InitialCap &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"invalid capacity settings"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//必须有创建方法</span></span><br><span class="line">	<span class="keyword">if</span> config.Factory == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"invalid factory func settings"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> config.Close == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"invalid close func settings"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	genericPool := &amp;GenericPool&#123;</span><br><span class="line">		connections:        <span class="built_in">make</span>(<span class="keyword">chan</span> *idleConn, config.MaxIdle),</span><br><span class="line">		factory:            config.Factory,</span><br><span class="line">		<span class="built_in">close</span>:              config.Close,</span><br><span class="line">		idleTimeout:        config.IdleTimeout,</span><br><span class="line">		maxActive:          config.MaxCap,</span><br><span class="line">		openingConnections: config.InitialCap,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> config.Ping != <span class="literal">nil</span> &#123;</span><br><span class="line">		genericPool.ping = config.Ping</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; config.InitialCap; i++ &#123;</span><br><span class="line">		conn, err := genericPool.factory()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			genericPool.Release()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"factory is not able to fill the pool: %s"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		genericPool.connections &lt;- &amp;idleConn&#123;conn: conn, t: time.Now()&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> genericPool, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>又累又饿又困，后续有机会再补上测试吧</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>连接池的最基本的保证，就是获取连接时候的线程安全。但是在实现诸多额外特性时候却又从不同角度来实现。还是非常有意思的。但是不管存储结构是用 chan 还是还是 slice，都可以很好的实现这一点。如果像 sql 或者 redis 那样用 slice 来存储连接，就得维护一个结构来表示排队等候的效果。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>数组算法训练</title>
    <url>/go/go-leetcode-slice/</url>
    <content><![CDATA[<blockquote>
<p>准备认真练习算法题目，个人使用Go语言进行练习，这是算法系列文章的第一篇。</p>
</blockquote>
<a id="more"></a>

<h2 id="LeetCode-数组专项训练"><a href="#LeetCode-数组专项训练" class="headerlink" title="LeetCode 数组专项训练"></a>LeetCode 数组专项训练</h2><h3 id="移动零-283"><a href="#移动零-283" class="headerlink" title="移动零 #283"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零 #283</a></h3><hr>
<blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
</blockquote>
<blockquote>
<p>示例:</p>
</blockquote>
<blockquote>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p>
</blockquote>
<blockquote>
<p>1.必须在原数组上操作，不能拷贝额外的数组。<br>2.尽量减少操作次数。</p>
</blockquote>
<hr>
<h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p>参考快速排序的方法，快速排序的思想就是首先确定一个待分割的元素作为中间点X,然后把所有小于x的元素放在左边，大于x的元素放在右边。</p>
<p>我们使用0作为分割点，把不是0的元素(可能是负数)放在左边，等于0的放在其右边，中间点就是0本身。只要使用指针zero和index即可，只有<code>nums[index]</code>不是0，就交换<code>nums[index]</code>和<code>nums[zero]</code>。如下动图所示：</p>
<p><img data-src="https://images.yangfan16.cn/leetcode-283-move-zeros.gif" alt="移动零"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    zero := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[index] != <span class="number">0</span> &#123;</span><br><span class="line">            nums[index],nums[zero] = nums[zero],nums[index]</span><br><span class="line">            zero++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解法2-快慢指针"><a href="#解法2-快慢指针" class="headerlink" title="解法2 快慢指针"></a>解法2 快慢指针</h5><p>利用快慢指针指针，如果快指针所指向的值为0，就把快指针往前走一步;如果不为0，慢指针与快指针所指向的元素进行交换，两个指针均往前走一步。代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fast,slow := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != <span class="number">0</span> &#123;</span><br><span class="line">            nums[fast],nums[slow] = nums[slow],nums[fast]</span><br><span class="line">            fast++</span><br><span class="line">            slow++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fast++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="加一-66"><a href="#加一-66" class="headerlink" title="加一 #66"></a><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">加一 #66</a></h4><hr>
<blockquote>
<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
</blockquote>
<blockquote>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
</blockquote>
<blockquote>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
</blockquote>
<blockquote>
<p>示例 1:</p>
</blockquote>
<blockquote>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br>示例 2:</p>
</blockquote>
<blockquote>
<p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p>
</blockquote>
<hr>
<p>依照常规的想法，从末尾开始遍历，如果值不是9，就把这个值加一并返回数组即可；如果值是9，就把这个值置为0，继续下一次循环即可；如果一直进位(例如：999)，就在前面添加个1，然后返回就好。代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index := <span class="built_in">len</span>(digits) <span class="number">-1</span> ; index &gt;= <span class="number">0</span>; index-- &#123;</span><br><span class="line">        <span class="keyword">if</span> digits[index] == <span class="number">9</span> &#123;</span><br><span class="line">            digits[index] = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          digits[index]++</span><br><span class="line">          <span class="keyword">return</span> digits</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;,digits...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="两数之和-1"><a href="#两数之和-1" class="headerlink" title="两数之和 #1"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">两数之和 #1</a></h4><hr>
<blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
</blockquote>
<blockquote>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
</blockquote>
<blockquote>
<p>示例 :</p>
</blockquote>
<blockquote>
<p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<hr>
<ol>
<li>先遍历数组nums,i为当前的下标，我们需要将每一个遍历的值放入<code>map</code>作为<code>key</code>。</li>
</ol>
<p><img data-src="https://images.yangfan16.cn/leetcode-1-twosum.jpeg" alt="两数之和"></p>
<ol start="2">
<li>同时对每个值都进行判断，看<code>map</code>中是否存在<code>key</code>为<code>target-nums[i]</code>的值。 在第二步的时候<code>9-7</code> 这个时候看到<code>map</code>中是有这个<code>key</code>的。</li>
</ol>
<p><img data-src="https://images.yangfan16.cn/leetcode-1-twosum-2.jpeg" alt="两数之和"></p>
<ol start="3">
<li>所以2和7所在的key对应的value,也就是[0,1],也就是我们需要找的两个数组的下标。</li>
</ol>
<p>所以代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>,target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">int</span></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="built_in">len</span>(nums))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index,value := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> val,ok := m[target-value];ok &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result,val)</span><br><span class="line">            result = <span class="built_in">append</span>(result,index)</span><br><span class="line">        &#125;</span><br><span class="line">        m[value] = index</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="旋转数组-189"><a href="#旋转数组-189" class="headerlink" title="旋转数组 #189"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">旋转数组 #189</a></h4><hr>
<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
</blockquote>
<blockquote>
<p>示例 1:</p>
</blockquote>
<blockquote>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>
</blockquote>
<blockquote>
<p>示例 2:</p>
</blockquote>
<blockquote>
<p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]</p>
</blockquote>
<hr>
<p>官方题解提供了四种解法，其中环状替代法和反转法是最靓的两种方法</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Go语言的哈希表</title>
    <url>/go/go-map/</url>
    <content><![CDATA[<blockquote>
<p>哈希表是除了数组之外最常用的数据结构，几乎任何语言都有数组和哈希表这两个集合的实现，有些语言(比如<code>Python</code>) 将哈希表称之为字典，将数组称之为列表。但是它们是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系，只是不同语言的叫法和实现稍微有些不同。Go语言中数组更常用到的是切片<code>slice</code>,哈希表则是<code>map</code></p>
</blockquote>
<a id="more"></a>

<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>哈希表的常用不仅因为它 <code>O(1)</code> 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数可以把给定的数据转换成固定长度的无规律数值。转换后的无规律数值可以作为 数据摘要应用于各种各样的场景；可以将哈希函数想像成搅拌机,可以总结出哈希函数的以下特点：</p>
<ol>
<li>输出的哈希值数据长度不变,与输入数据的长度大小无关；</li>
<li>若输入的数据相同，不管计算多少次，输出的结果一定一致；</li>
<li>即使输入的数据相似， 但哪怕它们只有一比特的差别， 那么输出的哈希值也会 有很大的差异；</li>
<li>即使输入的两个数据完全不同，输出的哈希值也有可能是相同的(即哈希冲突)；</li>
<li>不太可能从哈希值反向推算出原本的数据</li>
<li>求哈希值的计算要相对容易</li>
</ol>
<p><img data-src="evernotecid://12F4696D-A931-47AB-BBEB-8BF6431E1DDA/appyinxiangcom/22258662/ENResource/p22" alt="5d965c890d5586146dda72be407a8ab0.png"></p>
<p>哈希函数的选择在很大程度上能够决定哈希表的读写性能，在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求<strong>哈希函数输出范围大于输入范围</strong>，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的结果是不可能实现的。</p>
<p>比较实际的方式是让<strong>哈希函数的结果能够尽可能的均匀分布</strong>，然后通过工程上的手段解决哈希冲突的问题，但是<strong>哈希的结果一定要尽可能均匀</strong>，结果不均匀的哈希函数会造成更多的冲突并导致更差的读写性能。</p>
<p>在一个使用结果较为均匀的哈希函数中，哈希的增删改查都需要 O(1) 的时间复杂度，但是非常不均匀的哈希函数会导致所有的操作都会占用最差 O(n) 的复杂度，所以在哈希表中使用好的哈希函数是至关重要的。</p>
<h3 id="哈希冲突解决"><a href="#哈希冲突解决" class="headerlink" title="哈希冲突解决"></a>哈希冲突解决</h3><p>在通常情况下，哈希函数输入的范围一定会远远大于输出的范围，所以在使用哈希表时一定会遇到冲突，哪怕我们使用了完美的哈希函数，当输入的键足够多最终也会造成冲突；然而我们的哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。</p>
<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>开放寻址法的核心思想是<strong>对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中</strong>，如果我们使用开放寻址法来实现哈希表，那么在支撑哈希表的数据结构就是数组，不过因为数组的长度有限。<br>我们将每个人的性别作为数 据进行存储，键为人名，值为对应的性别。当我们向当前哈希表写入新的数据时发生了冲突，就会将键值对写入到下一个不为空的位置.</p>
<p>开放寻址法首先计算出元素的直接哈希地址 <code>H ( key )</code> ，如果该存储单元已被其他元素占用，则继续查看地址为 <code>H ( key ) + d 2</code> 的存储单元，如此重复直至找到某个存储单元为空时，将关键字为 <code>key</code> 的数据元素存放到该单元。 </p>
<p>增量 <code>d</code> 可以有不同的取法，并根据其取法有不同的称呼：</p>
<ol>
<li>di ＝ 1 ， 2 ， 3 ， …… 线性探测再哈希；</li>
<li>di ＝ 1^2 ，－ 1^2 ， 2^2 ，－ 2^2 ， k^2， -k^2…… 二次探测再哈希；</li>
<li>di ＝ 伪随机序列 伪随机再散列； </li>
</ol>
<p>开放寻址法中对性能影响最大的就是<code>装载因子</code>，它是数组中元素的数量与数组大小的比值，随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会同时影响哈希表的读写性能，当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找任意元素都需要遍历数组中全部的元素，所以在实现哈希表时一定要时刻关注装载因子的变化。</p>
<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>拉链法是哈希表中最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。</p>
<p>实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成一个可以扩展的『二维数组』：</p>
<p><img data-src="evernotecid://12F4696D-A931-47AB-BBEB-8BF6431E1DDA/appyinxiangcom/22258662/ENResource/p26" alt="2a4b4cfd1e9be8f66cac6b14de3c2197.png"></p>
<p>如上图所示，当需要将某个键值对写入哈希表中的时候，先对键经历一个哈希过程，就是搅拌机的搅拌过程，这个会帮我们选择一个桶，和开放地址法一样，选择桶的方式就是直接对哈希返回的结果取模：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">index := hash(<span class="string">"Ally"</span>) % array.<span class="built_in">len</span></span><br></pre></td></tr></table></figure>

<p>选择了 3 号桶之后就可以遍历当前桶中的链表了，在遍历链表的过程中会遇到以下两种情况:</p>
<ol>
<li>找到键相同的键值对 —— 更新键对应的值；</li>
<li>没有找到键相同的键值对 —— 在链表的末尾追加新键值对；</li>
</ol>
<p>当读取数据的时候，先找到桶的标号，然后依次遍历桶中的链表(有些是红黑树)，如果遍历到链表的末尾也没有找到期望的键，那就返回空。</p>
<p>在一个性能比较好的哈希表中，每一个桶中都应该有 0<del>1 个元素，有时会有 2</del>3 个，很少会超过这个数量，计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念：</p>
<blockquote>
<p>装载因子 := 元素数量 / 桶数量</p>
</blockquote>
<p>拉链法的装载因子越大，哈希的读写性能就越差，在一般情况下使用拉链法的哈希表装载因子都不会超过 1，当哈希表的装载因子较大时就会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。</p>
<h2 id="Go语言哈希表"><a href="#Go语言哈希表" class="headerlink" title="Go语言哈希表"></a>Go语言哈希表</h2><p><code>Go</code> 语言运行时同时使用了多个数据结构组合表示哈希表，其中使用 <code>hmap</code> 结构体来表示哈希，看一下这个结构体内部的字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type hmap struct &#123;</span><br><span class="line">	count     int</span><br><span class="line">	flags     uint8</span><br><span class="line">	B         uint8</span><br><span class="line">	noverflow uint16</span><br><span class="line">	hash0     uint32</span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer</span><br><span class="line">	oldbuckets unsafe.Pointer</span><br><span class="line">	nevacuate  uintptr</span><br><span class="line"></span><br><span class="line">	extra *mapextra</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>count</code> 表示当前哈希表中的元素数量；</li>
<li><code>B</code> 表示当前哈希表持有的 <code>buckets</code> 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 <code>len(buckets) == 2^B</code>；</li>
<li><code>hash0</code> 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；</li>
<li><code>oldbuckets</code> 是哈希在扩容时用于保存之前 <code>buckets</code> 的字段，它的大小是当前 <code>buckets</code> 的一半；</li>
</ol>
<p><img data-src="evernotecid://12F4696D-A931-47AB-BBEB-8BF6431E1DDA/appyinxiangcom/22258662/ENNote/p23?hash=ed2701bc8291c06642a6dcae3dc54ea9" alt="ed2701bc8291c06642a6dcae3dc54ea9.png"></p>
<p>如上图所示哈希表 <code>hmap</code> 的桶就是 <code>bmap</code>，每一个 <code>bmap</code> 都能存储 8 个键值对，当哈希表中存储的数据过多，单个桶无法装满时就会使用 <code>extra.overflow</code> 中桶存储溢出的数据。上述两种不同的桶在内存中是连续存储的，我们在这里将它们分别称为正常桶和溢出桶，上图中黄色的 <code>bmap</code> 就是正常桶，绿色的 <code>bmap</code> 是溢出桶，溢出桶是在 <code>Go</code> 语言还使用 <code>C</code> 语言实现时就使用的设计3，由于它能够减少扩容的频率所以一直使用至今。</p>
<p><code>bmap</code>的定义在<code>Go</code>语言的源码中如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	topbits  [<span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="keyword">uintptr</span></span><br><span class="line">    overflow <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>topbits</code>存储了键的哈希的高 8 位，通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>Go</code>语言可以通过字面量或者<code>map</code>关键字在运行时来初始化哈希表，我们分开来说。</p>
<h4 id="使用字面量"><a href="#使用字面量" class="headerlink" title="使用字面量"></a>使用字面量</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">"name"</span>: <span class="string">"青梅"</span>,</span><br><span class="line">	<span class="string">"age"</span>: ”<span class="number">20</span><span class="string">",</span></span><br><span class="line"><span class="string">	"</span>gender<span class="string">": "</span>male<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在初始化哈希时需要声明键值对的类型，这种使用字面量初始化的方式最终都会通过<code>cmd/compile/internal/gc/sinit.go</code>文件中的<code>maplit</code>函数进行初始化，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maplit</span><span class="params">(n *Node, m *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	a := nod(OMAKE, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">	a.Esc = n.Esc</span><br><span class="line">	a.List.Set2(typenod(n.Type), nodintconst(<span class="keyword">int64</span>(n.List.Len())))</span><br><span class="line">	litas(m, a, init)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> stat, dyn []*Node</span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> n.List.Slice() &#123;</span><br><span class="line">		stat = <span class="built_in">append</span>(stat, r)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(stat) &gt; <span class="number">25</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		addMapEntries(m, stat, init)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当哈希表中的元素数量少于或者等于 25 个时，编译器会直接调用 <code>addMapEntries</code> 将字面量初始化的结构体转换成以下的代码，将所有的键值对一次加入到哈希表中，这种方式像极了数组和切片的初始化方式，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">"name"</span>] = “青梅”</span><br><span class="line">hash[<span class="string">"age"</span>] = <span class="string">"20"</span></span><br><span class="line">hash[<span class="string">"gender"</span>] = <span class="string">"male"</span></span><br></pre></td></tr></table></figure>

<p>一旦超过25个，会在编译期间创建两个数组分别存储键和值的信息，这些键值对会通过一个如下所示的 for 循环加入目标的哈希：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">26</span>)</span><br><span class="line">vstatk := []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, ... ， <span class="string">"Z"</span>&#125;</span><br><span class="line">vstatv := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ... , <span class="number">26</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstak); i++ &#123;</span><br><span class="line">    hash[vstatk[i]] = vstatv[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的两个切片还会被进一步展开初始化，在数组和切片系列文章已经分析过了，就不再赘述。不过可以看到，无论hash中的元素数目比25个多还是少，在哈希表的初始化都是使用的<code>make</code>关键字进行初始化的。</p>
<h4 id="使用make关键字"><a href="#使用make关键字" class="headerlink" title="使用make关键字"></a>使用make关键字</h4><p>使用 <code>make</code> 创建哈希，<code>Go</code> 语言编译器会在类型检查期间将它们转换成对 <code>runtime.makemap</code> 的调用，使用字面量来初始化哈希也只是语言提供的辅助工具，最后调用的都是 <code>runtime.makemap</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">unc makemap(t *maptype, hint <span class="keyword">int</span>, h *hmap) *hmap &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(<span class="keyword">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">		hint = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize Hmap</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = <span class="built_in">new</span>(hmap)</span><br><span class="line">	&#125;</span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the size parameter B which will hold the requested # of elements.</span></span><br><span class="line">	<span class="comment">// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.</span></span><br><span class="line">	B := <span class="keyword">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocate initial hash table</span></span><br><span class="line">	<span class="comment">// if B == 0, the buckets field is allocated lazily later (in mapassign)</span></span><br><span class="line">	<span class="comment">// If hint is large zeroing this memory could take a while.</span></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的执行过程会分成以下几个部分：</p>
<ol>
<li>计算哈希占用的内存是否溢出或者超出能分配的最大值；</li>
<li>调用 fastrand 获取一个随机的哈希种子；</li>
<li>根据传入的 hint 计算出需要的最小需要的桶的数量；</li>
<li>使用 runtime.makeBucketArray 创建用于保存桶的数组；</li>
</ol>
<p><code>makeBucketArray</code> 函数会根据传入的 <code>B</code> 计算出的需要创建的桶数量在内存中分配一片连续的空间用于存储数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="keyword">uint8</span>, dirtyalloc unsafe.Pointer)</span> <span class="params">(buckets unsafe.Pointer, nextOverflow *bmap)</span></span> &#123;</span><br><span class="line">	base := bucketShift(b)</span><br><span class="line">	nbuckets := base</span><br><span class="line">	<span class="comment">// For small b, overflow buckets are unlikely.</span></span><br><span class="line">	<span class="comment">// Avoid the overhead of the calculation.</span></span><br><span class="line">	<span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">		<span class="comment">// Add on the estimated number of overflow buckets</span></span><br><span class="line">		<span class="comment">// required to insert the median number of elements</span></span><br><span class="line">		<span class="comment">// used with this value of b.</span></span><br><span class="line">		nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">		sz := t.bucket.size * nbuckets</span><br><span class="line">		up := roundupsize(sz)</span><br><span class="line">		<span class="keyword">if</span> up != sz &#123;</span><br><span class="line">			nbuckets = up / t.bucket.size</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当桶的数量小于 <code>2^4</code> 时，由于数据较少、使用溢出桶的可能性较低，这时就会省略创建的过程以减少额外开销；当桶的数量多于 <code>2^4</code> 时，就会额外创建 <code>2^𝐵−4</code> 个溢出桶，在正常情况下，正常桶和溢出桶在内存中的存储空间是连续的，只是被 <code>hmap</code> 中的不同字段引用，当溢出桶数量较多时会通过 <code>runtime.newobject</code> 创建新的溢出桶。</p>
<h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">val := hash[key]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, val :=  <span class="keyword">range</span> hash &#123;</span><br><span class="line">    <span class="comment">// k, v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种方式虽然都能读取哈希表中的数据，但是使用的函数和底层的原理完全不同，前者需要知道哈希的键并且一次只能获取单个键对应的值，而后者可以遍历哈希中的全部键值对，访问数据时也不需要预先知道哈希的键。</p>
<p><code>Go</code>语言还提供了一个内置的<code>delete</code>函数来删除哈希表中的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash[key] &#x3D; value</span><br><span class="line">hash[key] &#x3D; newValue</span><br><span class="line">delete(hash, key)</span><br></pre></td></tr></table></figure>

<h4 id="根据键访问"><a href="#根据键访问" class="headerlink" title="根据键访问"></a>根据键访问</h4><p>在编译的类型检查期间，<code>hash[key]</code> 以及类似的操作都会被转换成对哈希的 <code>OINDEXMAP</code> 操作，中间代码生成阶段会在 <code>cmd/compile/internal/gc/walk.go</code>文件中的<code>walkexpr</code>函数中将这些 <code>OINDEXMAP</code> 操作转换成如下的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v     := hash[key] <span class="comment">// =&gt; v     := *mapaccess1(maptype, hash, &amp;key)</span></span><br><span class="line">v, ok := hash[key] <span class="comment">// =&gt; v, ok := mapaccess2(maptype, hash, &amp;key)</span></span><br></pre></td></tr></table></figure>

<ol>
<li>接受参数仅为一个时，会使用 <code>runtime.mapaccess1</code>，该函数仅会返回一个指向目标值的指针；</li>
<li>接受两个参数时，会使用 <code>runtime.mapaccess2</code>，除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的布尔值：</li>
</ol>
<p><code>mapaccess1</code> 函数会先通过哈希表设置的哈希函数、种子获取当前键对应的哈希，再通过 <code>bucketMask</code> 和 <code>add</code> 函数拿到该键值对所在的桶序号和哈希最上面的 8 位数字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">	m := bucketMask(h.B)</span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">				<span class="keyword">return</span> v</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="range访问"><a href="#range访问" class="headerlink" title="range访问"></a>range访问</h4><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>当形如 <code>hash[k]</code> 的表达式出现在赋值符号左侧时，该表达式也会在编译期间转换成调用 <code>runtime.mapassign</code> 函数，该函数与 <code>runtime.mapaccess1</code> 比较相似，我们将该其分成几个部分分析，首先是函数会根据传入的键拿到对应的哈希和桶：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">	h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">	b := (*bmap)(unsafe.Pointer(<span class="keyword">uintptr</span>(h.buckets) + bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	top := tophash(hash)</span><br></pre></td></tr></table></figure>
<p>通过遍历比较桶中存储的 tophash 和键的哈希，如果找到了相同结果就会获取目标位置的地址并返回，其中<code>inserti</code> 表示目标元素的在桶中的索引，insertk 和 val 分别表示键值对的地址，获得目标地址之后会直接通过算术计算进行寻址获得键值对<code>k</code>和<code>val</code>：</p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Go语言数组和切片</title>
    <url>/go/go-slice-array/</url>
    <content><![CDATA[<blockquote>
<p>数组和切片是Go语言中常见的数据结构，很多刚刚使用Go的开发者往往会混淆这两个概念，数组作为最常见的集合在编程语言中是非常重要的，除了数组之外，Go 语言引入了另一个概念 — 切片，切片与数组有一些类似，但是它们的不同之处导致使用上会产生巨大的差别。我个人对于算法专项使用Go语言来进行练习，因此只涉及Go语言的部分实现和原理。</p>
</blockquote>
<a id="more"></a>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的概念"><a href="#数组的概念" class="headerlink" title="数组的概念"></a>数组的概念</h3><p>数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问元素对应的存储地址，常见的数组大多都是一维的线性数组，而多维数组在数值和图形计算领域却有比较常见的应用1。</p>
<p><img data-src="https://images.yangfan16.cn/go-arrary.jpeg" alt="多维数组"></p>
<p>数组作为一种基本的数据类型，通常都会从两个维度描述数组，首先需要描述数组中存储的元素类型，还需要描述数组最大能够存储的元素个数，在 Go 语言中我们往往会使用如下所示的方式来表示数组类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span>]<span class="keyword">string</span></span><br><span class="line">[<span class="number">200</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>与很多语言不同，Go 语言中数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一个类型。</p>
<p>查看Go语言的源代码，在<code>$GOROOT/src/cmd/compile/internal/types/type.go</code>文件中可以看到新建一个数组的时候发生了什么事情：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewArray returns a new fixed-length array Type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArray</span><span class="params">(elem *Type, bound <span class="keyword">int64</span>)</span> *<span class="title">Type</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> bound &lt; <span class="number">0</span> &#123;</span><br><span class="line">		Fatalf(<span class="string">"NewArray: invalid bound %v"</span>, bound)</span><br><span class="line">	&#125;</span><br><span class="line">	t := New(TARRAY)</span><br><span class="line">	t.Extra = &amp;Array&#123;Elem: elem, Bound: bound&#125;</span><br><span class="line">	t.SetNotInHeap(elem.NotInHeap())</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Go程序编译期间，数组的类型由上述<code>NewArray</code>函数生成，类型 <code>Array</code> 包含两个字段，一个是元素类型 <code>Elem</code>，另一个是数组的大小 <code>Bound</code>，这两个字段共同构成了数组类型，而当前数组是否应该在堆还是栈中初始化也在编译期就确定了。</p>
<h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>Go 语言中的数组有两种不同的创建方式，一种是显式的指定数组的大小，另一种是使用 […]T 声明数组，Go 语言会在编译期间通过源代码对数组的大小进行推断：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr1 := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">arr2 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>上述两种声明方式在运行期间得到的结果是完全相同的，后面的那种方式会被『转换』成为前一种，这个就是编译器对数组大小的推导</p>
<h4 id="数组大小推导过程"><a href="#数组大小推导过程" class="headerlink" title="数组大小推导过程"></a>数组大小推导过程</h4><p>上述两种不同的声明方式会导致编译器做出完全不同的处理，如果我们使用第一种方式 [5]T，那么变量的类型在编译进行到类型检查阶段就会被提取出来，随后会使用<code>cmd/compile/internal/types/type.go</code>中的<code>NewArrary</code>函数创建包含数组大小的 Array 类型。</p>
<p>当我们使用 <code>[...]T</code> 的方式声明数组时，虽然在这一步也会创建一个 <code>Array</code> 类型 <code>Array{Elem: elem, Bound: -1}</code>，但是其中的数组大小上限会是 -1，这里的 -1 只是一个占位符，编译器会在后面的 <code>cmd/compile/internal/gc/typecheck.go</code>文件中的 函数中对该数组的大小进行推导，具体的代码如下：</p>
<p>这个<code>typecheckcomplit</code>函数使用一个<code>typecheckarraylit</code>的函数来确定数组中元素的数量。我们继续往下追</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The result of typecheckcomplit MUST be assigned back to n, e.g.</span></span><br><span class="line"><span class="comment">// 	n.Left = typecheckcomplit(n.Left)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheckcomplit</span><span class="params">(n *Node)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Need to handle [...]T arrays specially.</span></span><br><span class="line">	<span class="keyword">if</span> n.Right.Op == OTARRAY &amp;&amp; n.Right.Left != <span class="literal">nil</span> &amp;&amp; n.Right.Left.Op == ODDD &#123;</span><br><span class="line">		n.Right.Right = typecheck(n.Right.Right, ctxType)</span><br><span class="line">		<span class="keyword">if</span> n.Right.Right.Type == <span class="literal">nil</span> &#123;</span><br><span class="line">			n.Type = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> n</span><br><span class="line">		&#125;</span><br><span class="line">		elemType := n.Right.Right.Type</span><br><span class="line"></span><br><span class="line">		length := typecheckarraylit(elemType, <span class="number">-1</span>, n.List.Slice(), <span class="string">"array literal"</span>)</span><br><span class="line"></span><br><span class="line">		n.Op = OARRAYLIT</span><br><span class="line">		n.Type = types.NewArray(elemType, length)</span><br><span class="line">		n.Right = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typecheckarraylit type-checks a sequence of slice/array literal elements.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheckarraylit</span><span class="params">(elemType *types.Type, bound <span class="keyword">int64</span>, elts []*Node, ctx <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="comment">// If there are key/value pairs, create a map to keep seen</span></span><br><span class="line">	<span class="comment">// keys so we can check for duplicate indices.</span></span><br><span class="line">	<span class="keyword">var</span> indices <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> _, elt := <span class="keyword">range</span> elts &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    key++</span><br><span class="line">		<span class="keyword">if</span> key &gt; length &#123;</span><br><span class="line">			length = key</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，Go1.14.2的代码中对于这种<code>[...]T</code>声明的数组，单独抽了一个方法，但是还是通过遍历每个元素的方式来确定数组的长度。 另外，因为声明这种数组时需要使用三个点（Dot），所以在编译器中就被称作 DDDArray。</p>
<p>所以我们可以看出 […]T{1, 2, 3} 和 [3]T{1, 2, 3} 在运行时是完全等价的，[…]T 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时就可以通过这种方法较少一些工作。</p>
<h4 id="语句转换"><a href="#语句转换" class="headerlink" title="语句转换"></a>语句转换</h4><p>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <code>cmd/compile/internal/gc/sinit.go</code>文件中的<code>anylit</code>函数中做两种不同的优化：</p>
<ul>
<li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li>
<li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anylit</span><span class="params">(n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	t := n.Type</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> OSTRUCTLIT, OARRAYLIT:</span><br><span class="line">		<span class="keyword">if</span> !t.IsStruct() &amp;&amp; !t.IsArray() &#123;</span><br><span class="line">			Fatalf(<span class="string">"anylit: not struct/array"</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> var_.isSimpleName() &amp;&amp; n.List.Len() &gt; <span class="number">4</span> &#123;</span><br><span class="line">			<span class="comment">// lay out static data</span></span><br><span class="line">			vstat := staticname(t)</span><br><span class="line">			vstat.Name.SetReadonly(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">			ctxt := inInitFunction</span><br><span class="line">			<span class="keyword">if</span> n.Op == OARRAYLIT &#123;</span><br><span class="line">				ctxt = inNonInitFunction</span><br><span class="line">			&#125;</span><br><span class="line">			fixedlit(ctxt, initKindStatic, n, vstat, init)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// copy static to var</span></span><br><span class="line">			a := nod(OAS, var_, vstat)</span><br><span class="line">    </span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>

<p>当数组的元素小于或者等于四个时，<code>cmd/compile/internal/gc/sinit.go</code>的文件中的<code>fixedlit</code>函数 会负责在函数编译之前将 [3]{1, 2, 3} 转换成更加原始的语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/ fixedlit handles <span class="keyword">struct</span>, array, and slice literals.</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> expand documentation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fixedlit</span><span class="params">(ctxt initContext, kind initKind, n *Node, var_ *Node, init *Nodes)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> splitnode <span class="function"><span class="keyword">func</span><span class="params">(*Node)</span> <span class="params">(a *Node, value *Node)</span></span></span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> n.List.Slice() &#123;</span><br><span class="line">		a, value := splitnode(r)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> value.Op &#123;</span><br><span class="line">		<span class="keyword">case</span> OSLICELIT:</span><br><span class="line">			<span class="keyword">if</span> (kind == initKindStatic &amp;&amp; ctxt == inNonInitFunction) || (kind == initKindDynamic &amp;&amp; ctxt == inInitFunction) &#123;</span><br><span class="line">				slicelit(ctxt, value, a, init)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> OARRAYLIT, OSTRUCTLIT:</span><br><span class="line">			fixedlit(ctxt, kind, value, a, init)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		islit := isLiteral(value)</span><br><span class="line">		<span class="keyword">if</span> (kind == initKindStatic &amp;&amp; !islit) || (kind == initKindDynamic &amp;&amp; islit) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// build list of assignments: var[index] = expr</span></span><br><span class="line">		setlineno(a)</span><br><span class="line">		a = nod(OAS, a, value)</span><br><span class="line">		a = typecheck(a, ctxStmt)</span><br><span class="line">		<span class="keyword">switch</span> kind &#123;</span><br><span class="line">		<span class="keyword">case</span> initKindStatic:</span><br><span class="line">			genAsStatic(a)</span><br><span class="line">		<span class="keyword">case</span> initKindDynamic, initKindLocalCode:</span><br><span class="line">			a = orderStmtInPlace(a, <span class="keyword">map</span>[<span class="keyword">string</span>][]*Node&#123;&#125;)</span><br><span class="line">			a = walkstmt(a)</span><br><span class="line">			init.Append(a)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			Fatalf(<span class="string">"fixedlit: bad kind %d"</span>, kind)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>当数组中的元素数目小于四个的时候，<code>kind</code>的接受的值是<code>initKindLocalCode</code>，述代码会将原有的初始化语句 [3]int{1, 2, 3} 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>如果当前数组的元素大于 4 个，在上面的<code>anylit</code> 方法会先获取一个唯一的<code>staticname</code> ,然后会调用上面的<code>fixedlit</code>方法，在静态存储区初始化数组中的元素并将临时变量赋值给当前的数组。</p>
<p>总结起来，如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件。</p>
<h3 id="访问和赋值"><a href="#访问和赋值" class="headerlink" title="访问和赋值"></a>访问和赋值</h3><p>无论是在栈上还是静态存储区，数组在内存中其实就是一连串的内存空间，表示数组的方法就是一个指向数组开头的指针、数组中元素的数量以及数组中元素类型占的空间大小，如果我们不知道数组中元素的数量，访问时就可能发生越界，而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据，如果没有这些信息，我们就无法知道这片连续的内存空间到底存储了什么数据：</p>
<p><img data-src="https://images.yangfan16.cn/go-arrary-global-memory.png" alt="数组内存结构"></p>
<p>数组访问越界是非常严重的错误，Go 语言中对越界的判断是可以在编译期间由静态类型检查完成的，<code>cmd/compile/internal/gc/typecheck.go</code>中的<code>typecheck1</code>函数会对访问数组的索引进行验证：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The result of typecheck1 MUST be assigned back to n, e.g.</span></span><br><span class="line"><span class="comment">// 	n.Left = typecheck1(n.Left, top)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> enableTrace &amp;&amp; trace &#123;</span><br><span class="line">		<span class="keyword">defer</span> tracePrint(<span class="string">"typecheck1"</span>, n)(&amp;res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	<span class="keyword">case</span> OLITERAL, ONAME, ONONAME, OTYPE:</span><br><span class="line">		<span class="keyword">if</span> n.Sym == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> n.Op == ONAME &amp;&amp; n.SubOp() != <span class="number">0</span> &amp;&amp; top&amp;ctxCallee == <span class="number">0</span> &#123;</span><br><span class="line">			yyerror(<span class="string">"use of builtin %v not in function call"</span>, n.Sym)</span><br><span class="line">			n.Type = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> n</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !n.Bounded() &amp;&amp; Isconst(n.Right, CTINT) &#123;</span><br><span class="line">				x := n.Right.Int64()</span><br><span class="line">				<span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">					yyerror(<span class="string">"invalid %s index %v (index must be non-negative)"</span>, why, n.Right)</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.IsArray() &amp;&amp; x &gt;= t.NumElem() &#123;</span><br><span class="line">					yyerror(<span class="string">"invalid array index %v (out of bounds for %d-element array)"</span>, n.Right, t.NumElem())</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> Isconst(n.Left, CTSTR) &amp;&amp; x &gt;= <span class="keyword">int64</span>(<span class="built_in">len</span>(strlit(n.Left))) &#123;</span><br><span class="line">					yyerror(<span class="string">"invalid string index %v (out of bounds for %d-byte string)"</span>, n.Right, <span class="built_in">len</span>(strlit(n.Left)))</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> n.Right.Val().U.(*Mpint).Cmp(maxintval[TINT]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">					yyerror(<span class="string">"invalid %s index %v (index too large)"</span>, why, n.Right)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>


<ul>
<li>访问数组的索引是非整数时会直接报错 —— non-integer array index %v；</li>
<li>访问数组的索引是负数时会直接报错 —— “invalid array index %v (index must be non-negative)”；</li>
<li>访问数组的索引越界时会直接报错 —— “invalid array index %v (out of bounds for %d-element array)”；</li>
</ul>
<p>数组和字符串的一些简单越界错误都会在编译期间发现，直接使用整数或者常量访问数组，但是如果使用变量去访问数组或者字符串时，编译器就无法发现对应的错误了，这时就需要 Go 语言运行时发挥作用了；Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 panicIndex 和 runtime.goPanicIndex 函数触发程序的运行时错误并导致崩溃退出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·panicIndex(SB),NOSPLIT,$<span class="number">0</span><span class="number">-8</span></span><br><span class="line">	MOVL	AX, x+<span class="number">0</span>(FP)</span><br><span class="line">	MOVL	CX, y+<span class="number">4</span>(FP)</span><br><span class="line">	JMP	runtime·goPanicIndex(SB)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goPanicIndex</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	panicCheck1(getcallerpc(), <span class="string">"index out of range"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(boundsError&#123;x: <span class="keyword">int64</span>(x), signed: <span class="literal">true</span>, y: y, code: boundsIndex&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，而在运行期间这些插入的函数会负责保证不会发生越界错误。</p>
<p>数组的赋值和更新操作也会生成 SSA ，生成期间计算出数组当前元素的内存地址，然后修改当前内存地址的内容。</p>
<p>赋值的过程中会先确定目标数组的地址，再通过 PtrIndex 获取目标元素的地址，最后使用 Store 指令将数据存入地址中，从上面的这些 SSA 代码中我们可以看出无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>数组在Go语言中其实并不常用，更常用的数据结构是切片，切片就是动态数组，其长度并不固定，我们可以随意向切片中追加元素，而且切片会在容量不足的时候自动扩容。</p>
<p>切片类型的声明方式与数组有一些相似，由于切片的长度是动态的，所以声明时只需要指定切片中的元素类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]<span class="keyword">int</span></span><br><span class="line">[]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>从切片的定义能推测出，切片在编译期间的生成的类型只会包含切片中的元素类型，即<code>int</code>或者 <code>interface{}</code> 等。<code>ccmd/compile/internal/types/type.go</code>文件中的<code>NewSlice</code>方法就是编译期间用于创建 Slice 类型的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewSlice returns the slice Type with element type elem.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlice</span><span class="params">(elem *Type)</span> *<span class="title">Type</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t := elem.Cache.slice; t != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t.Elem() != elem &#123;</span><br><span class="line">			Fatalf(<span class="string">"elem mismatch"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t := New(TSLICE)</span><br><span class="line">	t.Extra = Slice&#123;Elem: elem&#125;</span><br><span class="line">	elem.Cache.slice = t</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法返回的结构体<code>TSLICE</code> 中的 <code>Extra</code> 字段是一个只包含切片内元素类型的 <code>Slice{Elem: elem}</code> 结构，也就是说切片内元素的类型是在编译期间确定的，编译器确定了类型之后，会将类型存储在 Extra 字段中帮助程序在运行时动态获取。</p>
<h3 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h3><p>编译期间的切片是 Slice 类型的，但是在运行时切片由如下的 SliceHeader 结构体表示，其中 Data 字段是指向数组的指针，Len 表示当前切片的长度，而 Cap 表示当前切片的容量，也就是 Data 数组的大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SliceHeader is the runtime representation of a slice.</span></span><br><span class="line"><span class="comment">// It cannot be used safely or portably and its representation may</span></span><br><span class="line"><span class="comment">// change in a later release.</span></span><br><span class="line"><span class="comment">// Moreover, the Data field is not sufficient to guarantee the data</span></span><br><span class="line"><span class="comment">// it references will not be garbage collected, so programs must keep</span></span><br><span class="line"><span class="comment">// a separate, correctly typed pointer to the underlying data.</span></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">	Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Data</code>作为一个指针，指向的数组是一片连续的内存空间。这片内存空间可以用于存储切片中保存的所有元素。数组中的元素只逻辑上的概念，底层的存储其实都是连续的。所以可以将切片理解成一片连续的内存空间加上长度与容量的标识。</p>
<p><img data-src="https://images.yangfan16.cn/go-slice-struct.png" alt="Go切片结构"></p>
<p>官方解释Slice就是底层数组的一个View，切片引入了一个抽象层，提供了对数组中部分片段的引用，作为数组的引用，我们可以在运行区间可以修改它的长度，如果底层的数组长度不足就会触发扩容机制，切片中的数组就会发生变化，不过在上层看来切片时没有变化的，上层只需要与切片打交道不需要关心底层的数组变化。</p>
<p>Go语言获取数组大小、对数组中的元素的读写在编译期间就已经进行了简化，由于数组的内存固定且连续，很多操作都会变成对内存的直接读写；但是切片是运行时才会确定内容的结构，所有的操作还需要依赖 Go 语言的运行时来完成。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Go切片初始化有三种方式：</p>
<ol>
<li>通过下标的方式获得数组或者切片的一部分；</li>
<li>使用字面量初始化新的切片；</li>
<li>使用关键字<code>make</code>创建切片：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr[0:3] or slice[0:3]</span><br><span class="line">slice :&#x3D; []int&#123;1, 2, 3&#125;</span><br><span class="line">slice :&#x3D; make([]int, 10)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="使用下标"><a href="#使用下标" class="headerlink" title="使用下标"></a>使用下标</h4><p>这是最原始，最底层，也是最接近汇编语言的方式，这种操作会被编译器转换为<code>OpSliceMake</code>操作，<br>在<code>cmd/compile/internal/types/type.go</code>文件中的<code>NewSlice</code>可以看到具体操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewSlice returns the slice Type with element type elem.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlice</span><span class="params">(elem *Type)</span> *<span class="title">Type</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t := elem.Cache.slice; t != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t.Elem() != elem &#123;</span><br><span class="line">			Fatalf(<span class="string">"elem mismatch"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t := New(TSLICE)</span><br><span class="line">	t.Extra = Slice&#123;Elem: elem&#125;</span><br><span class="line">	elem.Cache.slice = t</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以写一段简单的代码看一下发生了什么：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSlice</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	arr := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	slice := arr[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">	<span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := newSlice()</span><br><span class="line">	fmt.Print(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以使用<code>GOSSAFUNC</code> 生成中间代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ GOSSAFUNC=main <span class="keyword">go</span> build op_slice_make.<span class="keyword">go</span></span><br><span class="line"># runtime</span><br><span class="line">dumped SSA to /usr/local/<span class="keyword">go</span>/src/runtime/ssa.html</span><br><span class="line"># command-line-arguments</span><br><span class="line">dumped SSA to ./ssa.html</span><br></pre></td></tr></table></figure>

<p>可以在<code>decompose builtin</code>阶段，<code>slice := arr[0:3]</code> 对应的部分:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name &amp;arr[*[<span class="number">6</span>]<span class="keyword">int</span>]: v11</span><br><span class="line">name slice.ptr[*<span class="keyword">int</span>]: v11</span><br><span class="line">name slice.<span class="built_in">len</span>[<span class="keyword">int</span>]: v14</span><br><span class="line">name slice.<span class="built_in">cap</span>[<span class="keyword">int</span>]: v17</span><br></pre></td></tr></table></figure>

<p>也就是说其实切片的底层是数组，只是包含了三个部分:数组指针，切片大小和容量。同时在SSA中还可以看到<code>v27 (7) = SliceMake &lt;[]int&gt; v11 v25 v26 (~r0[[]int], slice[[]int], s[[]int])</code> , <code>SliceMake</code> 这个操作需要接受元素类型，数组指针，切片大小和切片容量来创建新的切片。</p>
<h4 id="使用字面量"><a href="#使用字面量" class="headerlink" title="使用字面量"></a>使用字面量</h4><p>我们除了使用下标的方式创建切片，还可以使用字面量来创建切片<code>[]int{1,2,3,4,5}</code>,在<code>cmd/compile/internal/gc/sinit.go</code>文件的<code>slicelit</code>函数会将这个展开成为下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vstat [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">vstat[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">vstat[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">vstat[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">vstat[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">vstat[<span class="number">4</span>] = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> vauto *[<span class="number">5</span>]<span class="keyword">int</span> = <span class="built_in">new</span>([<span class="number">5</span>]<span class="keyword">int</span>)</span><br><span class="line">*vauto = vstat</span><br><span class="line">slice := vauto[:]</span><br></pre></td></tr></table></figure>

<ul>
<li>根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</li>
<li>将这些字面量元素存储到初始化的数组中；</li>
<li>建一个同样指向 [5]int 类型的数组指针；</li>
<li>将静态存储区的数组 vstat 赋值给 vauto 指针所在的地址；</li>
<li>通过 [:] 操作获取一个底层使用 vauto 的切片；</li>
</ul>
<p>我们能看到租后进行的<code>[:]</code>其实是创建切片的真实方法，也就是说<code>[:]</code>操作是创建切片最底层的一种方法。</p>
<h4 id="使用make关键字"><a href="#使用make关键字" class="headerlink" title="使用make关键字"></a>使用make关键字</h4><p>使用字面量的方式创建切片，大部分的工作就都会在编译期间完成，但是当我们使用 make 关键字创建切片时，很多工作都需要运行时的参与；调用方必须在 make 函数中传入一个切片的大小以及可选的容量。<br>在<code>cmd/compile/internal/gc/typecheck.go</code>文件的<code>typecheck1</code>方法中能看到,make的时候会对参数进行校验：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">case</span> OMAKE:</span><br><span class="line">		ok |= ctxExpr</span><br><span class="line">		args := n.List.Slice()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">			yyerror(<span class="string">"missing argument to make"</span>)</span><br><span class="line">			n.Type = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> n</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n.List.Set(<span class="literal">nil</span>)</span><br><span class="line">   </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">case</span> TSLICE:</span><br><span class="line">			<span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(args) &#123;</span><br><span class="line">				yyerror(<span class="string">"missing len argument to make(%v)"</span>, t)</span><br><span class="line">				n.Type = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			l = args[i]</span><br><span class="line">			i++</span><br><span class="line">			l = typecheck(l, ctxExpr)</span><br><span class="line">			<span class="keyword">var</span> r *Node</span><br><span class="line">			<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123;</span><br><span class="line">				r = args[i]</span><br><span class="line">				i++</span><br><span class="line">				r = typecheck(r, ctxExpr)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> l.Type == <span class="literal">nil</span> || (r != <span class="literal">nil</span> &amp;&amp; r.Type == <span class="literal">nil</span>) &#123;</span><br><span class="line">				n.Type = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !checkmake(t, <span class="string">"len"</span>, l) || r != <span class="literal">nil</span> &amp;&amp; !checkmake(t, <span class="string">"cap"</span>, r) &#123;</span><br><span class="line">				n.Type = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> Isconst(l, CTINT) &amp;&amp; r != <span class="literal">nil</span> &amp;&amp; Isconst(r, CTINT) &amp;&amp; l.Val().U.(*Mpint).Cmp(r.Val().U.(*Mpint)) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				yyerror(<span class="string">"len larger than cap in make(%v)"</span>, t)</span><br><span class="line">				n.Type = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.Left = l</span><br><span class="line">			n.Right = r</span><br><span class="line">			n.Op = OMAKESLICE</span><br><span class="line">           </span><br><span class="line">          ...</span><br><span class="line">      </span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>这个<code>typecheck1</code>函数不仅会检查<code>len</code>是否传入，还会保证传入的容量 <code>cap</code> 一定大于或者等于 <code>len</code>，除了校验参数之外，当前函数会将 <code>OMAKE</code> 节点转换成 <code>OMAKESLICE</code>，随后的中间代码生成阶段在 <code>cmd/compile/internal/gc/walk.go</code>文件中的<code>walkexpr</code> 函数中的 <code>OMAKESLICE</code> 分支依据两个重要条件对这里的 <code>OMAKESLICE</code> 进行转换：</p>
<ol>
<li>切片的大小和容量是否足够小</li>
<li>切片是否发生了逃逸，最终在堆上初始化</li>
</ol>
<p>当发生逃逸后者非常大的时候，在<code>runtime/slice.go</code>文件中的<code>makeslice</code>函数可以看到:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> Produce a 'len out of range' error instead of a</span></span><br><span class="line">		<span class="comment">// 'cap out of range' error when someone does make([]T, bignumber).</span></span><br><span class="line">		<span class="comment">// 'cap out of range' is true too, but since the cap is only being</span></span><br><span class="line">		<span class="comment">// supplied implicitly, saying len is clearer.</span></span><br><span class="line">		<span class="comment">// See golang.org/issue/4085.</span></span><br><span class="line">		mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">		<span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">			panicmakeslicelen()</span><br><span class="line">		&#125;</span><br><span class="line">		panicmakeslicecap()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>mallocgc</code>函数中还有一大段的注释解释了如何尽可能节约分配堆内存的空间。</p>
<p>总之，就是说在分配的切片比较小的情况下，会初始化数组并且直接通过下转换的方式来得到数组的切片，这两部分操作都会在编译阶段完成，编译器会在栈上或者静态存储区创建数组；而分配比较大或者出现逃逸的情况下会在堆上初始化。</p>
<p><code>makeslice</code>函数主要工作就是计算当前切片占用的内存空间并在堆上申请一片连续的内存，它使用如下的方式计算占用的内存：</p>
<blockquote>
<p>内存空间 = 切片中元素大小 x 切片容量</p>
</blockquote>
<p>创建切片的过程中如果发生了以下错误就会直接导致程序触发运行时错误并崩溃：</p>
<ol>
<li>内存空间的大小发生了溢出</li>
<li>申请的内存大于最大可分配的内存；</li>
<li>传入的长度小于 0 或者长度大于容量；</li>
</ol>
<p>Go的内存分配器实在是过于复杂，半天没研究出来什么有用的信息，就先跳过。</p>
<p><code>makeslice</code>函数会返回指向底层数组的指针，之前版本的 <code>Go</code> 语言中，数组指针、长度和容量会被合成一个 <code>slice</code> 结构并返回。现在改为构建结构体<code>SliceHeader</code>，这工作就都交给 <code>runtime.makeslice</code>的调用方处理了，这些调用方会在编译期间构建切片结构体。Go官方说这个改动能够减少 <code>~0.2%</code> 的 <code>Go</code> 语言包大小并且能够减少 92 个 <code>panicindex</code> 的调用，占整个 Go 语言二进制的 <code>~3.5%1</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">	Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>对切片常见的操作就是获取它的长度或者容量，这两个不同的函数 <code>len</code> 和 <code>cap</code> 被 <code>Go</code> 语言的编译器看成是两种特殊的操作，即 <code>OLEN</code> 和 <code>OCAP</code>，它们会在 <code>SSA</code> 生成阶段被 <code>cmd/compile/internal/gc/ssa.go</code>文件中的<code>expr</code>函数转换成 <code>OpSliceLen</code> 和 <code>OpSliceCap</code> 操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// expr converts the expression n to ssa, adds it to s and returns the ssa result.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OLEN, OCAP:</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> n.Left.Type.IsSlice():</span><br><span class="line">                op := ssa.OpSliceLen</span><br><span class="line">                <span class="keyword">if</span> n.Op == OCAP &#123;</span><br><span class="line">                    op = ssa.OpSliceCap</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> s.newValue1(op, types.Types[TINT], s.expr(n.Left))</span><br><span class="line">            <span class="keyword">case</span> n.Left.Type.IsString(): <span class="comment">// string; not reachable for OCAP</span></span><br><span class="line">                <span class="keyword">return</span> s.newValue1(ssa.OpStringLen, types.Types[TINT], s.expr(n.Left))</span><br><span class="line">            <span class="keyword">case</span> n.Left.Type.IsMap(), n.Left.Type.IsChan():</span><br><span class="line">                <span class="keyword">return</span> s.referenceTypeBuiltin(n, s.expr(n.Left))</span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">// array</span></span><br><span class="line">                <span class="keyword">return</span> s.constInt(types.Types[TINT], n.Left.Type.NumElem())</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>len(slice)</code> 或者 <code>cap(slice)</code> 在一些情况下会被直接替换成切片的长度或者容量，不需要运行时从切片结构中获取：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(SlicePtr (SliceMake ptr _ _ )) -&gt; ptr</span><br><span class="line">(SliceLen (SliceMake _ <span class="built_in">len</span> _)) -&gt; <span class="built_in">len</span></span><br><span class="line">(SliceCap (SliceMake _ _ <span class="built_in">cap</span>)) -&gt; <span class="built_in">cap</span></span><br></pre></td></tr></table></figure>

<p>除了获取切片的长度和容量之外，访问切片中元素使用的 OINDEX 操作也会在中间代码生成期间转换成对地址的直接访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">expr</span><span class="params">(n *Node)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OINDEX:</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> n.Left.Type.IsString():</span><br><span class="line">                <span class="keyword">if</span> n.Bounded() &amp;&amp; Isconst(n.Left, CTSTR) &amp;&amp; Isconst(n.Right, CTINT) &#123;</span><br><span class="line">                    <span class="comment">// Replace "abc"[1] with 'b'.</span></span><br><span class="line">                    <span class="comment">// Delayed until now because "abc"[1] is not an ideal constant.</span></span><br><span class="line">                    <span class="comment">// See test/fixedbugs/issue11370.go.</span></span><br><span class="line">                    <span class="keyword">return</span> s.newValue0I(ssa.OpConst8, types.Types[TUINT8], <span class="keyword">int64</span>(<span class="keyword">int8</span>(strlit(n.Left)[n.Right.Int64()])))</span><br><span class="line">                &#125;</span><br><span class="line">                a := s.expr(n.Left)</span><br><span class="line">                i := s.expr(n.Right)</span><br><span class="line">                <span class="built_in">len</span> := s.newValue1(ssa.OpStringLen, types.Types[TINT], a)</span><br><span class="line">                i = s.boundsCheck(i, <span class="built_in">len</span>, ssa.BoundsIndex, n.Bounded())</span><br><span class="line">                ptrtyp := s.f.Config.Types.BytePtr</span><br><span class="line">                ptr := s.newValue1(ssa.OpStringPtr, ptrtyp, a)</span><br><span class="line">                <span class="keyword">if</span> Isconst(n.Right, CTINT) &#123;</span><br><span class="line">                    ptr = s.newValue1I(ssa.OpOffPtr, ptrtyp, n.Right.Int64(), ptr)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ptr = s.newValue2(ssa.OpAddPtr, ptrtyp, ptr, i)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> s.load(types.Types[TUINT8], ptr)</span><br><span class="line">            <span class="keyword">case</span> n.Left.Type.IsSlice():</span><br><span class="line">                p := s.addr(n, <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> s.load(n.Left.Type.Elem(), p)</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，使用<code>range</code> 遍历切片时也会在编译期间转换成形式更简单的代码。</p>
<h3 id="range遍历"><a href="#range遍历" class="headerlink" title="range遍历"></a>range遍历</h3><h3 id="追加和扩容"><a href="#追加和扩容" class="headerlink" title="追加和扩容"></a>追加和扩容</h3><p>向切片中追加元素是非常常见的操作，在 <code>Go</code> 语言中我们会使用 <code>append</code> 关键字向切片追加元素，中间代码生成阶段的 <code>cmd/compile/internal/gc/ssa.go</code>文件中我们可以看到<code>append</code>方法，该方法追加元素会根据返回值是否会覆盖原变量，分别进入两种流程，如果 <code>append</code> 返回的『新切片』不需要赋值回原有的变量，就会进入如下的处理流程（代码中的注释）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := s</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> newlen &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">    ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> = growslice(s, newlen)</span><br><span class="line">	newlen = <span class="built_in">len</span> + <span class="number">3</span> <span class="comment">// recalculate to avoid a spill</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(ptr+<span class="built_in">len</span>) = e1</span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = e2</span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = e3</span><br><span class="line"><span class="keyword">return</span> makeslice(ptr, newlen, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>

<p>先对结构体进行解析，获取它的指针，大小和容量，如果在追加后切片的大小大于其容量，就会对切片进行扩容，使用的方法是<code>runtime/slice.go</code>文件中的<code>growslice</code>方法 ,扩容策略我们后面再讲；如果<code>append</code>后的切片会覆盖原来的切片，就会使用另一种方式改写关键字，在<code>cmd/compile/internal/gc/ssa.go</code>文件中<code>append</code>程序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := &amp;s</span><br><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := s</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uint</span>(newlen) &gt; <span class="keyword">uint</span>(<span class="built_in">cap</span>) &#123;</span><br><span class="line">    newptr, <span class="built_in">len</span>, newcap = growslice(ptr, <span class="built_in">len</span>, <span class="built_in">cap</span>, newlen)</span><br><span class="line">	vardef(a)       <span class="comment">// if necessary, advise liveness we are writing a new a</span></span><br><span class="line">	*a.<span class="built_in">cap</span> = newcap <span class="comment">// write before ptr to avoid a spill</span></span><br><span class="line">	*a.ptr = newptr <span class="comment">// with write barrier</span></span><br><span class="line">&#125;</span><br><span class="line">newlen = <span class="built_in">len</span> + <span class="number">3</span> <span class="comment">// recalculate to avoid a spill</span></span><br><span class="line">*a.<span class="built_in">len</span> = newlen</span><br><span class="line"><span class="comment">// with write barriers, if needed:</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>) = e1</span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = e2</span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = e3</span><br></pre></td></tr></table></figure>
<p>如果我们选择覆盖原有的变量，也不需要担心切片的拷贝，因为<code>Go</code>语言的编译器已经对这种情况作了优化。大概如下：</p>
<p><img data-src="https://images.yangfan16.cn/go-slice-append.jpeg" alt="slice扩容"></p>
<p>Go语言的切片扩容策略:</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片容量小于 1024 就会将容量翻倍；</li>
<li>如果当前切片容量大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li>
</ol>
<p>在<code>runtime/slice.go</code>文件中的<code>growslice</code>方法中能看到如下的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>确定了切片的容量之后，就可以计算切片中新数组占用的内存了，计算的方法就是将目标容量和元素大小相乘，计算新容量时可能会发生溢出或者请求的内存超过上限，这个时候就会出现<code>panic</code>。</p>
<p>若切片中元素不是指针类型，那么就会调用 <code>memclrNoHeapPointers</code> 将超出切片当前长度的位置清空并在最后使用 <code>memmove</code> 将原数组内存中的内容拷贝到新申请的内存中。这里的<code>memclrNoHeapPointers</code> 和<code>memmove</code>都是用目标机器上的汇编指令实现的。</p>
<p><code>growslice</code>函数最终会返回一个新的<code>slice</code>结构，其中包含了新的数组指针、大小和容量，这个返回的三元组最终会改变原有的切片，帮助 append 完成元素追加的功能。</p>
<h3 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h3><p>拷贝切片并不常用，<code>Go</code>提供了一个内置的<code>copy(a,b)</code>,在<code>cmd/compile/internal/gc/walk.go</code>文件中<code>copyany</code>函数能看到具体的操作 其实是分了两种情况处理，如果<code>copy</code>不是运行时调用，<code>copy(a,b)</code>会被直接转换为下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="built_in">len</span>(b) &#123;</span><br><span class="line">    n = <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a.ptr != b.ptr &#123;</span><br><span class="line">    memmove(a.ptr, b.ptr, n*sizeof(elem(a))) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>memmove</code> 会负责对内存进行拷贝，在其他情况下，编译器会使用 <code>slicecopy</code> 函数替换运行期间调用的 <code>copy</code>，例如：`go copy(a, b)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(to, fm slice, width <span class="keyword">uintptr</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fm.<span class="built_in">len</span> == <span class="number">0</span> || to.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	n := fm.<span class="built_in">len</span></span><br><span class="line">	<span class="keyword">if</span> to.<span class="built_in">len</span> &lt; n &#123;</span><br><span class="line">		n = to.<span class="built_in">len</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	size := <span class="keyword">uintptr</span>(n) * width</span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">1</span> &#123;</span><br><span class="line">		*(*<span class="keyword">byte</span>)(to.array) = *(*<span class="keyword">byte</span>)(fm.array)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		memmove(to.array, fm.array, size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种不同的拷贝方式一般都会通过 memmove 将整块内存中的内容拷贝到目标的内存区域中,如下图所示：<br><img data-src="https://images.yangfan16.cn/go-slice-copy.png" alt="切片扩容"></p>
<p>相比于依次对元素进行拷贝，这种方式能够提供更好的性能，但是需要注意的是，哪怕使用 <code>memmove</code> 对内存成块进行拷贝，但是这个操作还是会占用非常多的资源，在大切片上执行拷贝操作时一定要注意性能影响。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现有限状态机</title>
    <url>/go/go-state-machine/</url>
    <content><![CDATA[<blockquote>
<p>有限状态机(FSM)是计算的基本概念，在现实生活中发现许多FSM行为，例如自动售货机，电梯，交通信号灯等。基于FSM的编程也是建模复杂状态转换的强大工具，它可以大大简化我们的程序。</p>
</blockquote>
<h3 id="什么是有限状态机"><a href="#什么是有限状态机" class="headerlink" title="什么是有限状态机"></a>什么是有限状态机</h3><blockquote>
<p>有限状态机（FSM）或简称为状态机，是计算的数学模型。它是一种抽象机器，在任何给定时间都可以恰好处于有限数量的状态之一。FSM可以响应某些输入而从一种状态更改为另一种状态。从一种状态到另一种状态的变化称为过渡。<br>— 维基百科</p>
</blockquote>
<p>FSM由三个关键元素组成：初始状态，所有可能状态的列表，触发状态转换的输入。<br>让我们将旋转栅栏作为FSM建模的简单示例。</p>
<a id="more"></a>

<p><img data-src="https://upload.wikimedia.org/wikipedia/commons/9/9e/Turnstile_state_machine_colored.svg" alt="维基百科的旋转栅栏状态图"></p>
<p>像其他FSM一样，旋转闸门的状态机包含三个元素：</p>
<ul>
<li>其初始状态为“锁定”</li>
<li>它有两个可能的状态：“锁定”和“解锁”</li>
<li>有两个输入将触发状态更改：“Push”和“Coin”</li>
</ul>
<h3 id="Go建立基于FSM的程序"><a href="#Go建立基于FSM的程序" class="headerlink" title="Go建立基于FSM的程序"></a>Go建立基于FSM的程序</h3><p>将构建一个命令行程序来模拟旋转栅门的行为。程序启动时，提示用户键入一些命令，然后它将根据输入的命令更改其状态。</p>
<h4 id="版本一-简单形式实现FSM"><a href="#版本一-简单形式实现FSM" class="headerlink" title="版本一 简单形式实现FSM"></a>版本一 简单形式实现FSM</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// State the FSM state for turnstile</span></span><br><span class="line"><span class="keyword">type</span> State <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Locked locked state</span></span><br><span class="line">	Locked State = <span class="literal">iota</span></span><br><span class="line">	<span class="comment">// Unlocked unlocked state</span></span><br><span class="line">	Unlocked</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// CmdCoin command coin</span></span><br><span class="line">	CmdCoin = <span class="string">"coin"</span></span><br><span class="line">	<span class="comment">// CmdPush command push</span></span><br><span class="line">	CmdPush = <span class="string">"push"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	state := Locked</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	prompt(state)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		cmd, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalln(err)</span><br><span class="line">		&#125;</span><br><span class="line">		cmd = strings.TrimSpace(cmd)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">switch</span> state &#123;</span><br><span class="line">		<span class="keyword">case</span> Locked:</span><br><span class="line">			<span class="keyword">if</span> cmd == CmdCoin &#123;</span><br><span class="line">				fmt.Println(<span class="string">"unlocked, ready for pass through"</span>)</span><br><span class="line">				state = Unlocked</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> cmd == CmdPush &#123;</span><br><span class="line">				fmt.Println(<span class="string">"not allowed, unlock first"</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">"unknown command, try again please"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> Unlocked:</span><br><span class="line">			<span class="keyword">if</span> cmd == CmdCoin &#123;</span><br><span class="line">				fmt.Println(<span class="string">"well, don't waste your coin"</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> cmd == CmdPush &#123;</span><br><span class="line">				fmt.Println(<span class="string">"pass through, shift back to locked"</span>)</span><br><span class="line">				state = Locked</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">"unknown command, try again please"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prompt</span><span class="params">(s State)</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[State]<span class="keyword">string</span>&#123;</span><br><span class="line">		Locked:   <span class="string">"Locked"</span>,</span><br><span class="line">		Unlocked: <span class="string">"Unlocked"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"current state is [%s], please input command [coin|push]\n"</span>, m[s])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，定义两个状态（Locked &amp; Unlocked）和两个有效命令（CmdCoin &amp; CmdPush）。在函数中main，我们将初始状态设置为Locked，向用户打印使用情况信息。然后开始主循环，从中读取命令字符串stdin，根据当前状态处理该命令。</p>
<p>您可能会注意到，我们必须为每个状态处理未知命令，这可以通过较小的重构得到改善。此外，如果将状态转换逻辑提取到函数中，则程序将更具表现力。</p>
<h4 id="版本二-重构代码以使得更加清晰"><a href="#版本二-重构代码以使得更加清晰" class="headerlink" title="版本二 重构代码以使得更加清晰"></a>版本二 重构代码以使得更加清晰</h4><p>在主循环中我们只关心，输入的有效命令和初始状态，完全可以将状态装换的逻辑代码抽成一个单独的函数，具体代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// State the FSM state for turnstile</span></span><br><span class="line"><span class="comment">// 指出FSM的状态以便表示旋转门</span></span><br><span class="line"><span class="keyword">type</span> State <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Locked locked state</span></span><br><span class="line">	<span class="comment">// 锁定状态</span></span><br><span class="line">	Locked State = <span class="literal">iota</span></span><br><span class="line">	<span class="comment">// Unlocked unlocked state</span></span><br><span class="line">	<span class="comment">// 解锁状态</span></span><br><span class="line">	Unlocked</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// CmdCoin command coin</span></span><br><span class="line">	<span class="comment">// 命令CmdCoin表示coin输入</span></span><br><span class="line">	CmdCoin = <span class="string">"coin"</span></span><br><span class="line">	<span class="comment">// CmdPush command push</span></span><br><span class="line">	<span class="comment">// 命令CmdPush表示push输入</span></span><br><span class="line">	CmdPush = <span class="string">"push"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	state := Locked</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	prompt(state)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		cmd, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalln(err)</span><br><span class="line">		&#125;</span><br><span class="line">		state = step(state, strings.TrimSpace(cmd))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">step</span><span class="params">(state State, cmd <span class="keyword">string</span>)</span> <span class="title">State</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> cmd != CmdCoin &amp;&amp; cmd != CmdPush &#123;</span><br><span class="line">		fmt.Println(<span class="string">"unknown command, try again please"</span>)</span><br><span class="line">		<span class="keyword">return</span> state</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> state &#123;</span><br><span class="line">	<span class="keyword">case</span> Locked:</span><br><span class="line">		<span class="keyword">if</span> cmd == CmdCoin &#123;</span><br><span class="line">			fmt.Println(<span class="string">"unlocked, ready for pass through"</span>)</span><br><span class="line">			state = Unlocked</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"not allowed, unlock first"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> Unlocked:</span><br><span class="line">		<span class="keyword">if</span> cmd == CmdCoin &#123;</span><br><span class="line">			fmt.Println(<span class="string">"well, don't waste your coin"</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"pass through, shift back to locked"</span>)</span><br><span class="line">			state = Locked</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prompt</span><span class="params">(s State)</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[State]<span class="keyword">string</span>&#123;</span><br><span class="line">		Locked:   <span class="string">"Locked"</span>,</span><br><span class="line">		Unlocked: <span class="string">"Unlocked"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"current state is [%s], please input command [coin|push]\n"</span>, m[s])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>实际上，状态机通常由<a href="https://en.wikipedia.org/wiki/State-transition_table" target="_blank" rel="noopener">State-Transition Table</a>表示，对于我们的旋转门示例，该表如下所示：<br><img data-src="https://miro.medium.com/max/700/1*O_2x8lMfIF4XjnAjoJcfEw.png" alt="维基百科的状态转换表"></p>
<p>我们可以使用转换表来实现FSM</p>
<h4 id="版本三-状态转换表"><a href="#版本三-状态转换表" class="headerlink" title="版本三 状态转换表"></a>版本三 状态转换表</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// State the FSM state for turnstile</span></span><br><span class="line"><span class="comment">// 指出FSM的状态以便表示旋转门</span></span><br><span class="line"><span class="keyword">type</span> State <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Locked locked state</span></span><br><span class="line">	<span class="comment">// 锁定状态</span></span><br><span class="line">	Locked State = <span class="literal">iota</span></span><br><span class="line">	<span class="comment">// Unlocked unlocked state</span></span><br><span class="line">	<span class="comment">// 解锁状态</span></span><br><span class="line">	Unlocked</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// CmdCoin command coin</span></span><br><span class="line">	<span class="comment">// 命令CmdCoin表示coin输入</span></span><br><span class="line">	CmdCoin = <span class="string">"coin"</span></span><br><span class="line">	<span class="comment">// CmdPush command push</span></span><br><span class="line">	<span class="comment">// 命令CmdPush表示push输入</span></span><br><span class="line">	CmdPush = <span class="string">"push"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	state := Locked</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	prompt(state)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// read command from stdin</span></span><br><span class="line">		cmd, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalln(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// get function from transition table</span></span><br><span class="line">		<span class="comment">//从状态转换表里面获取状态</span></span><br><span class="line">		tupple := CommandStateTupple&#123;strings.TrimSpace(cmd), state&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> f := StateTransitionTable[tupple]; f == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"unknown command, try again please"</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			f(&amp;state)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommandStateTupple tupple for state-command combination</span></span><br><span class="line"><span class="comment">// 状态命令组合的元组</span></span><br><span class="line"><span class="keyword">type</span> CommandStateTupple <span class="keyword">struct</span> &#123;</span><br><span class="line">	Command <span class="keyword">string</span></span><br><span class="line">	State   State</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransitionFunc transition function</span></span><br><span class="line"><span class="comment">// 状态转换函数</span></span><br><span class="line"><span class="keyword">type</span> coin <span class="function"><span class="keyword">func</span><span class="params">(state *State)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StateTransitionTable trsition table</span></span><br><span class="line"><span class="comment">//状态转换表</span></span><br><span class="line"><span class="keyword">var</span> StateTransitionTable = <span class="keyword">map</span>[CommandStateTupple]TransitionFunc&#123;</span><br><span class="line">	&#123;CmdCoin, Locked&#125;: <span class="function"><span class="keyword">func</span><span class="params">(state *State)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"unlocked, ready for pass through"</span>)</span><br><span class="line">		*state = Unlocked</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;CmdPush, Locked&#125;: <span class="function"><span class="keyword">func</span><span class="params">(state *State)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"not allowed, unlock first"</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;CmdCoin, Unlocked&#125;: <span class="function"><span class="keyword">func</span><span class="params">(state *State)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"well, don't waste your coin"</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;CmdPush, Unlocked&#125;: <span class="function"><span class="keyword">func</span><span class="params">(state *State)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"pass through, shift back to locked"</span>)</span><br><span class="line">		*state = Locked</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prompt</span><span class="params">(s State)</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[State]<span class="keyword">string</span>&#123;</span><br><span class="line">		Locked:   <span class="string">"Locked"</span>,</span><br><span class="line">		Unlocked: <span class="string">"Unlocked"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"current state is [%s], please input command [coin|push]\n"</span>, m[s])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方法，所有可能的转换都在表中列出。易于维护和理解。如果需要新的转换，只需添加一个表条目。<br>由于FSM是抽象机器，因此我们可以更进一步，并以面向对象的方式实现它。</p>
<h4 id="版本四-使用类对FSM进行建模"><a href="#版本四-使用类对FSM进行建模" class="headerlink" title="版本四 使用类对FSM进行建模"></a>版本四 使用类对FSM进行建模</h4><p>Turnstile引入了一个新类，它具有一个属性State，即名为的方法ExecuteCmd。<br>触发状态转换的唯一方法是调用方法ExecuteCmd。<br>该关系可以用下面的图表示：</p>
<p><img data-src="https://miro.medium.com/max/700/1*bnQTaea8YizYi5SPPsSU0g.png" alt="oop类图"></p>
<p>重新写一下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// State the FSM state for turnstile</span></span><br><span class="line"><span class="keyword">type</span> State <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Locked locked state</span></span><br><span class="line">	Locked State = <span class="literal">iota</span></span><br><span class="line">	<span class="comment">// Unlocked unlocked state</span></span><br><span class="line">	Unlocked</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// CmdCoin command coin</span></span><br><span class="line">	CmdCoin = <span class="string">"coin"</span></span><br><span class="line">	<span class="comment">// CmdPush command push</span></span><br><span class="line">	CmdPush = <span class="string">"push"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Turnstile the finite state machine</span></span><br><span class="line"><span class="keyword">type</span> Turnstile <span class="keyword">struct</span> &#123;</span><br><span class="line">	State State</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExecuteCmd execute command</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Turnstile)</span> <span class="title">ExecuteCmd</span><span class="params">(cmd <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// get function from transition table</span></span><br><span class="line">	tupple := CmdStateTupple&#123;strings.TrimSpace(cmd), p.State&#125;</span><br><span class="line">	<span class="keyword">if</span> f := StateTransitionTable[tupple]; f == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"unknown command, try again please"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		f(&amp;p.State)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	machine := &amp;Turnstile&#123;State: Locked&#125;</span><br><span class="line">	prompt(machine.State)</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// read command from stdin</span></span><br><span class="line">		cmd, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalln(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		machine.ExecuteCmd(cmd)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CmdStateTupple tupple for state-command combination</span></span><br><span class="line"><span class="keyword">type</span> CmdStateTupple <span class="keyword">struct</span> &#123;</span><br><span class="line">	Cmd   <span class="keyword">string</span></span><br><span class="line">	State State</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransitionFunc transition function</span></span><br><span class="line"><span class="keyword">type</span> TransitionFunc <span class="function"><span class="keyword">func</span><span class="params">(state *State)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// StateTransitionTable trsition table</span></span><br><span class="line"><span class="keyword">var</span> StateTransitionTable = <span class="keyword">map</span>[CmdStateTupple]TransitionFunc&#123;</span><br><span class="line">	&#123;CmdCoin, Locked&#125;: <span class="function"><span class="keyword">func</span><span class="params">(state *State)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"unlocked, ready for pass through"</span>)</span><br><span class="line">		*state = Unlocked</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;CmdPush, Locked&#125;: <span class="function"><span class="keyword">func</span><span class="params">(state *State)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"not allowed, unlock first"</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;CmdCoin, Unlocked&#125;: <span class="function"><span class="keyword">func</span><span class="params">(state *State)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"well, don't waste your coin"</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;CmdPush, Unlocked&#125;: <span class="function"><span class="keyword">func</span><span class="params">(state *State)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"pass through, shift back to locked"</span>)</span><br><span class="line">		*state = Locked</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prompt</span><span class="params">(s State)</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[State]<span class="keyword">string</span>&#123;</span><br><span class="line">		Locked:   <span class="string">"Locked"</span>,</span><br><span class="line">		Unlocked: <span class="string">"Unlocked"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"current state is [%s], please input command [coin|push]\n"</span>, m[s])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单学习了FSM的概念并构建了一个基于FSM的Go程序，实现了这个程序的四个版本：</p>
<ul>
<li>v1，以简单的形式实现FSM。</li>
<li>进行一些重构，抽出函数以减少代码重复</li>
<li>使用状态转换表</li>
<li>采用OOP的方式进行重构</li>
</ul>
<p>状态机的思想在编码中还是会遇到，例如解耦一些复杂的任务，实现接口幂等，分解程序逻辑，使得代码更急清晰等等。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Podman 初体验</title>
    <url>/others/podman-experience/</url>
    <content><![CDATA[<blockquote>
<p>最近把自己的虚拟机升级到了CetnOS 8,内核版本4.18.0-147.8.1.el8_1.x86_64，感觉带来的变化还是很大，网络管理彻底替换了 network.service，防火墙管理等等。居然还去Docker，引进了新一代的容器管理工具（😢 国内很多开发都还没用docker，就已经去docker了）,使用 Podman、Buildah(提供构建image的能力)、Skopeo(提供远程仓库的镜像管理能力) ,对docker进行了替换。 我体验了下 Podman,谨做小文以记。</p>
</blockquote>
<a id="more"></a>

<h3 id="为啥不用Docker"><a href="#为啥不用Docker" class="headerlink" title="为啥不用Docker"></a>为啥不用Docker</h3><p>我觉得主要是因为docker需要运行一个守护进程，docker的稳定性问题（感觉在向好的趋势不断发展，其实远比podman稳定多了），还有的话就是root运行。随着K8S抛弃CRI标准，CRI-O进入CNCF孵化阶段,国外越来越多的在使用CRI-O 来替代Docker,Docker正在被大家抛弃 (:–</p>
<h3 id="podman特色"><a href="#podman特色" class="headerlink" title="podman特色"></a>podman特色</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>podman创建容器不需要守护进程，可以用普通用户创建容器。podman的命令方式与docker没有什么太大的区别，可以认为 alias docker=podman，会用docker就会用podman。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>有一个podman-compose(但是还没有release1.0)，不是很好用。与docker-compose还有很大的差距。</li>
<li>更新频繁(你永远不知道这个锅是你的问题还是podman的问题，心累)</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>CenOS8默认就是podman，docker安装反倒是需要去安装仓库源。 直接运行<code>sudo yum install podman -y</code>就行</p>
<p><code>yum info podman</code> 能看到以下信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">名称         : podman</span><br><span class="line">版本         : 1.6.4</span><br><span class="line">发布         : 4.module_el8.1.0+298+41f9343a</span><br><span class="line">架构         : x86_64</span><br><span class="line">大小         : 55 M</span><br><span class="line">源           : podman-1.6.4-4.module_el8.1.0+298+41f9343a.src.rpm</span><br><span class="line">仓库         : @System</span><br><span class="line">来自仓库     : AppStream</span><br><span class="line">概况         : Manage Pods, Containers and Container Images</span><br><span class="line">URL          : https://podman.io/</span><br><span class="line">协议         : ASL 2.0</span><br><span class="line">描述         : podman (Pod Manager) is a fully featured container engine that is a simple daemonless tool.  podman provides a Docker-CLI</span><br><span class="line">             : comparable command line that eases the transition from other container engines and allows the management of pods, containers and</span><br><span class="line">             : images.  Simply put: alias docker=podman.  Most podman commands can be run as a regular user, without requiring additional</span><br><span class="line">             : privileges.</span><br><span class="line">             :</span><br><span class="line">             : podman uses Buildah(1) internally to create container images. Both tools share image (not container) storage, hence each can use</span><br><span class="line">             : or manipulate images (but not containers) created by the other.</span><br><span class="line">             :</span><br><span class="line">             : Manage Pods, Containers and Container Images</span><br><span class="line">             : libpod Simple management tool for pods, containers and images</span><br></pre></td></tr></table></figure>

<h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><h4 id="podman-rpm中附带的文件"><a href="#podman-rpm中附带的文件" class="headerlink" title="podman rpm中附带的文件"></a>podman rpm中附带的文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpm -ql podman | grep -v <span class="string">"/usr/share/doc/"</span></span></span><br><span class="line">/etc/cni/net.d/87-podman-bridge.conflist</span><br><span class="line">/usr/bin/podman</span><br><span class="line">/usr/lib/.build-id</span><br><span class="line">/usr/lib/.build-id/82</span><br><span class="line">/usr/lib/.build-id/82/21ca637b743ef63235a38b3195f6563a96967a</span><br><span class="line">/usr/lib/systemd/system/io.podman.service</span><br><span class="line">/usr/lib/systemd/system/io.podman.socket</span><br><span class="line">/usr/lib/systemd/user/io.podman.service</span><br><span class="line">/usr/lib/systemd/user/io.podman.socket</span><br><span class="line">/usr/lib/tmpfiles.d/podman.conf</span><br><span class="line">/usr/share/bash-completion/completions/podman</span><br><span class="line">/usr/share/containers/libpod.conf</span><br><span class="line">/usr/share/licenses/podman</span><br><span class="line">/usr/share/licenses/podman/LICENSE</span><br><span class="line">/usr/share/man/man5/oci-hooks.5.gz</span><br><span class="line">/usr/share/zsh/site-functions</span><br><span class="line">/usr/share/zsh/site-functions/_podman</span><br></pre></td></tr></table></figure>
<p>能看到的只有一个配置文件，就在<code>/etc/cni/net.d/</code>下面,与Bridge的配置有关,打开看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;87-podman-bridge.conflist</span><br><span class="line">&#123;</span><br><span class="line">  &quot;cniVersion&quot;: &quot;0.4.0&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;podman&quot;,</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="line">      &quot;bridge&quot;: &quot;cni-podman0&quot;,</span><br><span class="line">      &quot;isGateway&quot;: true,</span><br><span class="line">      &quot;ipMasq&quot;: true,</span><br><span class="line">      &quot;ipam&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="line">        &quot;routes&quot;: [&#123; &quot;dst&quot;: &quot;0.0.0.0&#x2F;0&quot; &#125;],</span><br><span class="line">        &quot;ranges&quot;: [</span><br><span class="line">          [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;subnet&quot;: &quot;10.88.0.0&#x2F;16&quot;,</span><br><span class="line">              &quot;gateway&quot;: &quot;10.88.0.1&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;portmap&quot;,</span><br><span class="line">      &quot;capabilities&quot;: &#123;</span><br><span class="line">        &quot;portMappings&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;tuning&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而安装的时候，能看到需要的一个重要依赖就是containers-common，这个里面有很多配置文件。<br><code>rpm -ql containers-common | grep -v &quot;/usr/share/man/&quot;</code> 可以查看具体的文件信息。</p>
<h4 id="registries-conf"><a href="#registries-conf" class="headerlink" title="registries.conf"></a>registries.conf</h4><p><code>/etc/containers/registries.conf</code> 用于保存 registries 相关配置：</p>
<h4 id="mounts-conf"><a href="#mounts-conf" class="headerlink" title="mounts.conf"></a>mounts.conf</h4><p>这个配置指定在执行 podman run 或者 podman build 命令时自动挂载的路径，该路径只会在容器运行时挂载，不会提交到容器镜像中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /usr/share/containers/mounts.conf</span></span><br><span class="line">/usr/share/rhel/secrets:/run/secrets</span><br></pre></td></tr></table></figure>

<h4 id="policy-json"><a href="#policy-json" class="headerlink" title="policy.json"></a>policy.json</h4><p>证书相关的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/containers/policy.json</span></span><br><span class="line">&#123;</span><br><span class="line">    "default": [</span><br><span class="line">        &#123;</span><br><span class="line">            "type": "insecureAcceptAnything"</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "transports":</span><br><span class="line">        &#123;</span><br><span class="line">            "docker-daemon":</span><br><span class="line">                &#123;</span><br><span class="line">                    "": [&#123;"type":"insecureAcceptAnything"&#125;]</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="images使用"><a href="#images使用" class="headerlink" title="images使用"></a>images使用</h3><blockquote>
<p>Ps:以下操作已经使得虚拟机可以科学上网，终端已经<code>export https_proxy</code><br>PPs: 我修改了下仓库，如下</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat  /etc/containers/registries.conf</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 仅仅改了下面部分</span></span><br><span class="line">[registries.search]</span><br><span class="line"><span class="meta">#</span><span class="bash">registries = [<span class="string">'registry.access.redhat.com'</span>, <span class="string">'registry.fedoraproject.org'</span>, <span class="string">'registry.centos.org'</span>, <span class="string">'docker.io'</span>]</span></span><br><span class="line">registries = ['registry.redhat.io','quay.io','docker.io','registry.access.redhat.com']</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h4 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ podman search nginx | head -6</span><br><span class="line">INDEX        NAME                                                                   DESCRIPTION                                       STARS   OFFICIAL   AUTOMATED</span><br><span class="line">redhat.io    registry.redhat.io&#x2F;rhscl&#x2F;nginx-112-rhel7                               Nginx is a web server and a reverse proxy se...   0</span><br><span class="line">redhat.io    registry.redhat.io&#x2F;rhel8&#x2F;nginx-116                                     Platform for running nginx 1.16 or building ...   0</span><br><span class="line">redhat.io    registry.redhat.io&#x2F;rhel8&#x2F;nginx-114                                     Nginx is a web server and a reverse proxy se...   0</span><br><span class="line">redhat.io    registry.redhat.io&#x2F;rhscl&#x2F;nginx-18-rhel7                                Nginx 1.8 server and a reverse proxy server       0</span><br><span class="line">redhat.io    registry.redhat.io&#x2F;rhscl&#x2F;nginx-110-rhel7                               Nginx container image that delivers an nginx...   0</span><br></pre></td></tr></table></figure>

<h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir -p $HOME&#x2F;padmon&#x2F;hello</span><br><span class="line">$ cd $HOME&#x2F;podman&#x2F;hello</span><br><span class="line">$ cat Dockerfile</span><br><span class="line">FROM docker.io&#x2F;library&#x2F;ubuntu:latest</span><br><span class="line"></span><br><span class="line">RUN echo &#39;hello&#39;</span><br><span class="line"># 第一次构建出错 </span><br><span class="line">podman build -t hello:1.0 .</span><br><span class="line">STEP 1: FROM docker.io&#x2F;library&#x2F;ubuntu:latest</span><br><span class="line">Getting image source signatures</span><br><span class="line">Copying blob fee5db0ff82f done</span><br><span class="line">Copying blob fc878cd0a91c done</span><br><span class="line">Copying blob d51af753c3d3 done</span><br><span class="line">Copying blob 6154df8ff988 done</span><br><span class="line">Error: error creating build container: Error writing blob: error storing blob to file &quot;&#x2F;var&#x2F;tmp&#x2F;storage169362295&#x2F;3&quot;: unexpected EOF</span><br><span class="line"># 我啥都没干，重新试了一下</span><br><span class="line">$ podman build -t hello:1.0 .</span><br><span class="line">STEP 1: FROM docker.io&#x2F;library&#x2F;ubuntu:latest</span><br><span class="line">Getting image source signatures</span><br><span class="line">Copying blob 6154df8ff988 done</span><br><span class="line">Copying blob d51af753c3d3 done</span><br><span class="line">Copying blob fee5db0ff82f done</span><br><span class="line">Copying blob fc878cd0a91c done</span><br><span class="line">Copying config 1d622ef86b done</span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">STEP 2: RUN echo &#39;hello&#39;</span><br><span class="line">hello</span><br><span class="line">STEP 3: COMMIT hello:1.0</span><br><span class="line">58013a9566306982c614d34f74ba6c658182a640e4fd31bd9a69698791b2f782</span><br><span class="line">$ podman images</span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED              SIZE</span><br><span class="line">localhost&#x2F;hello            1.0      58013a956630   About a minute ago   76.3 MB</span><br><span class="line">docker.io&#x2F;library&#x2F;ubuntu   latest   1d622ef86b13   10 days ago          76.3 MB</span><br></pre></td></tr></table></figure>

<h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">podman image pull nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">前两次失败，啥也没干，第三次成功 失败的原因是unexpected EOF</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从github的issue上来看显然不是我一个人人品不行,多尝试几次，有时候会成功。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> podman images</span></span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED         SIZE</span><br><span class="line">localhost/hello            1.0      58013a956630   9 minutes ago   76.3 MB</span><br><span class="line">docker.io/library/ubuntu   latest   1d622ef86b13   10 days ago     76.3 MB</span><br><span class="line">docker.io/library/nginx    latest   602e111c06b6   11 days ago     131 MB</span><br></pre></td></tr></table></figure>

<p>除了像 Docker 一样从网络拉取镜像，Podman 为了方便用户从 Docker 迁移过来，Podman 支持从本地的 docker daemon 中直接拉取镜像，如果没有 domain 的话，目前会自动补全 docker.io/library/ 前缀。</p>
<h4 id="检查和删除"><a href="#检查和删除" class="headerlink" title="检查和删除"></a>检查和删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ podman image inspect docker.io&#x2F;library&#x2F;nginx |head -n 15</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;602e111c06b6934013578ad80554a074049c59441d9bcd963cb4a7feccede7a5&quot;,</span><br><span class="line">        &quot;Digest&quot;: &quot;sha256:86ae264c3f4acb99b2dee4d0098c40cb8c46dcf9e1148f05d3a51c4df6758c12&quot;,</span><br><span class="line">        &quot;RepoTags&quot;: [</span><br><span class="line">            &quot;docker.io&#x2F;library&#x2F;nginx:latest&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;RepoDigests&quot;: [</span><br><span class="line">            &quot;docker.io&#x2F;library&#x2F;nginx@sha256:86ae264c3f4acb99b2dee4d0098c40cb8c46dcf9e1148f05d3a51c4df6758c12&quot;,</span><br><span class="line">            &quot;docker.io&#x2F;library&#x2F;nginx@sha256:cccef6d6bdea671c394956e24b0d0c44cd82dbe83f543a47fdc790fadea48422&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;Parent&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2020-04-23T13:03:01.355887897Z&quot;,</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">        </span><br><span class="line">$ podman image rm docker.io&#x2F;library&#x2F;nginx</span><br><span class="line">Untagged: docker.io&#x2F;library&#x2F;nginx:latest</span><br><span class="line">Deleted: 602e111c06b6934013578ad80554a074049c59441d9bcd963cb4a7feccede7a5</span><br><span class="line"></span><br><span class="line">$ podman images</span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED          SIZE</span><br><span class="line">localhost&#x2F;hello            1.0      58013a956630   11 minutes ago   76.3 MB</span><br><span class="line">docker.io&#x2F;library&#x2F;ubuntu   latest   1d622ef86b13   10 days ago      76.3 MB</span><br></pre></td></tr></table></figure>

<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="运行-停止和删除"><a href="#运行-停止和删除" class="headerlink" title="运行,停止和删除"></a>运行,停止和删除</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> podman images</span></span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED          SIZE</span><br><span class="line">localhost/hello            1.0      58013a956630   13 minutes ago   76.3 MB</span><br><span class="line">docker.io/library/ubuntu   latest   1d622ef86b13   10 days ago      76.3 MB</span><br><span class="line">docker.io/library/nginx    latest   602e111c06b6   11 days ago      131 MB</span><br><span class="line"><span class="meta">$</span><span class="bash"> podman run -it docker.io/library/ubuntu sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/issue</span></span><br><span class="line">Ubuntu 20.04 LTS \n \l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> podman ps -a</span></span><br><span class="line">CONTAINER ID  IMAGE                            COMMAND  CREATED        STATUS                         PORTS  NAMES</span><br><span class="line">6e20cab0d0dc  docker.io/library/ubuntu:latest  sh       2 minutes ago  Exited (0) About a minute ago         gallant_wright</span><br><span class="line"><span class="meta">$</span><span class="bash"> podman ps</span></span><br><span class="line">CONTAINER ID  IMAGE                            COMMAND  CREATED        STATUS            PORTS  NAMES</span><br><span class="line">4dffd4d2a97d  docker.io/library/ubuntu:latest  sh       3 seconds ago  Up 3 seconds ago         modest_dewdney</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> podman stop 4dffd4d2a97d</span></span><br><span class="line">4dffd4d2a97d079de9b777813b379fee66ed3b38b889545f764500032aefb1ec</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> podman rm 4dffd4d2a97d 6e20cab0d0dc</span></span><br><span class="line">4dffd4d2a97d079de9b777813b379fee66ed3b38b889545f764500032aefb1ec</span><br><span class="line">6e20cab0d0dc2007c51dc84fd2b3bd00caea2aa514b0e4f417646ba525ad5b16</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> podman ps -a</span></span><br><span class="line">CONTAINER ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES</span><br></pre></td></tr></table></figure>

<h3 id="checkpoint-restore"><a href="#checkpoint-restore" class="headerlink" title="checkpoint/restore"></a>checkpoint/restore</h3><p>Podman 提供了类似于 git 的功能，能够对 container 进行 checkpoint(commit)，并且可以 restore(checkout)，<a href="https://asciinema.org/a/FsTbx9mZkzeuhCM2pFOr1tujM" target="_blank" rel="noopener">看着很美好的样子</a>，我到这里已经不是很想验证了，毕竟构建或者拉取这样基础的操作都要靠人品，还是等子弹先飞一会儿再说。</p>
<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>podman提供了healthcheck功能，在运行容器时，可以通过参数<code>--healthcheck-command</code>来指定健康检查的方式，然后通过<code>podman healthcheck</code>命令来检测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ podman run -dt --name healthtest --healthcheck-command &#39;CMD-SHELL curl https:&#x2F;&#x2F;www.baidu.com || exit 1&#39; --healthcheck-interval&#x3D;0 nginx:latest</span><br><span class="line">b3fa86705f2acfb59bcaa8bbed0a531e6fa17092593768a66bec56ba98623550</span><br><span class="line">$ podman healthcheck run healthtest</span><br><span class="line">unhealthy</span><br></pre></td></tr></table></figure>

<p>我到现在没明白我运行容器不健康的原因，我看了一堆issue，貌似各种说法不一，没有再深究下去。</p>
<h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><p>Podman没有daemon，没办法像docker一样通过指定参数<code>--restart=always</code>在docker进程启动时自动拉起镜像。 而采用systemd来支持该功能。</p>
<p>到这里我已经无力吐槽，完全没有再实验的动力了，暂时先空着吧，或许以后有机会我又会变心喜欢也有可能呢，到时候再研究这个怎么玩。</p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>总得对得起名字啊，主要不就是为了吹k8s pod概念嘛（： 根据podman自己的目标和说法，对于最终要运行在k8s环境的来说，Podman非常适合，能很大的减少环境不通导致的工作量，Podman的YAML和k8s pod yaml文件格式是兼容的。</p>
<p><img data-src="https://images.yangfan16.cn/podman-pod.jpeg" alt="podman pod架构"></p>
<h4 id="先创建一个pod"><a href="#先创建一个pod" class="headerlink" title="先创建一个pod"></a>先创建一个pod</h4><p>瞅瞅帮助命令， 基本上想要的都还有。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> podman pod --<span class="built_in">help</span></span></span><br><span class="line">Manage pods</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line">  Pods are a group of one or more containers sharing the same network, pid and ipc namespaces.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  podman pod [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  create      Create a new empty pod</span><br><span class="line">  exists      Check if a pod exists in local storage</span><br><span class="line">  inspect     Displays a pod configuration</span><br><span class="line">  kill        Send the specified signal or SIGKILL to containers in pod</span><br><span class="line">  pause       Pause one or more pods</span><br><span class="line">  prune       Remove all stopped pods</span><br><span class="line">  ps          List pods</span><br><span class="line">  restart     Restart one or more pods</span><br><span class="line">  rm          Remove one or more pods</span><br><span class="line">  start       Start one or more pods</span><br><span class="line">  stats       Display a live stream of resource usage statistics for the containers in one or more pods</span><br><span class="line">  stop        Stop one or more pods</span><br><span class="line">  top         Display the running processes of containers in a pod</span><br><span class="line">  unpause     Unpause one or more pods</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> podman pod create --<span class="built_in">help</span></span></span><br><span class="line">Create a new empty pod</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line">  After creating the pod, the pod ID is printed to stdout.</span><br><span class="line"></span><br><span class="line">  You can then start it at any time with the  podman pod start &lt;pod_id&gt; command. The pod will be created with the initial state 'created'.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  podman pod create [flags]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      --cgroup-parent string   Set parent cgroup for the pod</span><br><span class="line">      --hostname string        Set a hostname to the pod</span><br><span class="line">      --infra                  Create an infra container associated with the pod to share namespaces with (default true)</span><br><span class="line">      --infra-command string   The command to run on the infra container when the pod is started (default "/pause")</span><br><span class="line">      --infra-image string     The image of the infra container to associate with the pod (default "k8s.gcr.io/pause:3.1")</span><br><span class="line">  -l, --label strings          Set metadata on pod (default [])</span><br><span class="line">      --label-file strings     Read in a line delimited file of labels</span><br><span class="line">  -n, --name string            Assign a name to the pod</span><br><span class="line">      --pod-id-file string     Write the pod ID to the file</span><br><span class="line">  -p, --publish strings        Publish a container's port, or a range of ports, to the host (default [])</span><br><span class="line">      --share string           A comma delimited list of kernel namespaces the pod will share (default "cgroup,ipc,net,uts")</span><br></pre></td></tr></table></figure>

<p>创建一个pod, 由于重新打开了终端窗口失去了科学上网的proxy,第一次timeout了，一顿操作后创建成功了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> podman pod create --name test_stack</span></span><br><span class="line">217143af2d6a44fe4fee99263d01bf26ca6cf287e62b4d3807fa968daea8ef7f</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> podman run -dt --pod new:web_server -p 8080:80 nginx</span></span><br><span class="line">e6336a56d0f217adb9938142fd0e1d98dd4b733140b7c88f4825359c096c4d3a</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> podman pod list</span></span><br><span class="line">POD ID         NAME         STATUS    CREATED          # OF CONTAINERS   INFRA ID</span><br><span class="line">01e985f62511   web_server   Running   7 seconds ago    2                 ae0341aac4c7</span><br><span class="line">9474f961f6e9   test_stack   Created   50 seconds ago   1                 ce0c41bf1c79</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> podman pod ps</span></span><br><span class="line">POD ID         NAME         STATUS    CREATED         # OF CONTAINERS   INFRA ID</span><br><span class="line">01e985f62511   web_server   Running   2 minutes ago   2                 ae0341aac4c7</span><br><span class="line">9474f961f6e9   test_stack   Created   2 minutes ago   1                 ce0c41bf1c79</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl localhost -I</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 612</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Mon, 04 May 2020 13:43:33 GMT</span><br><span class="line">Etag: "5e95c66e-264"</span><br><span class="line">Keep-Alive: timeout=4</span><br><span class="line">Last-Modified: Tue, 14 Apr 2020 14:19:26 GMT</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Server: nginx/1.17.10</span><br></pre></td></tr></table></figure>

<p>创建了两个pod节点，web_server这个pod中有一个容器nginx，并且暴露端口给外面，通过curl可以很轻易的验证是否正常工作。也可以检查根据端口查看哪个进程在使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ss -tplun | grep 80</span></span><br><span class="line">tcp   LISTEN  0       1                    0.0.0.0:80           0.0.0.0:*      users:(("slirp4netns",pid=28816,fd=8))</span><br></pre></td></tr></table></figure>

<p>但是坑爹是的我stop这个pod，想要再次起来却始终无法起来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> podman pod start web_server</span></span><br><span class="line">ERRO[0000] "error starting some containers: container already exists"</span><br><span class="line">ERRO[0000] "error from slirp4netns while setting up port redirection: map[desc:bad request: add_hostfwd: slirp_add_hostfwd failed]"</span><br><span class="line">Error: a dependency of container e6336a56d0f217adb9938142fd0e1d98dd4b733140b7c88f4825359c096c4d3a failed to start: container state improper</span><br></pre></td></tr></table></figure>

<p>emmmm,我理解新东西坑多点，但这个真的不是很好用啊。一开始还有给提issue的想法，现在完全没有一点意愿做这件事，而且在解决问题的过程中，能看到不少issue和我遇到的是相同的问题，都被粗暴的关闭了。</p>
<h3 id="k8s联动"><a href="#k8s联动" class="headerlink" title="k8s联动"></a>k8s联动</h3><p>通过<code>podman generate</code>命令可以生成k8s可用的YAML文件，使用<code>podman play</code>命令可以直接创建完整的 Pod 及其所拥有的容器。 但是这个还是遇到了一个<code>no matching entries in passwd file</code>。 我没有继续尝试下去的勇气😔</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果从Docker迁移过来，估计大半还是要抓狂：</p>
<ol>
<li>缺少国内镜像源，没有科学上网，什么都做不了，即使有，也要看运气。</li>
<li>说好了rootless, 但是你要是想对端口映射，还是得老老实实的sudo,否则就是各种各样的问题。</li>
<li>各种不稳定，编译失败，拉取失败，启动pod失败，关闭pod失败，关键是很多错误根本就不知道自己错在了哪里，过一会儿又会成功。</li>
<li>还需要更多地用户去采坑，去修复更多地问题。</li>
<li>文档资源稀缺，几乎全是英文的，而且都是很简单的示例，不知道能不能经受的生产环境的各种考验。</li>
</ol>
<p>总体来说，现在没有docker香，以后返回来看就不好说了。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>podman</tag>
      </tags>
  </entry>
  <entry>
    <title>端午上海苏州游记</title>
    <url>/travel/travel-sh-note/</url>
    <content><![CDATA[<blockquote>
<p>结婚以来，一直都各种忙，没有时间出去，也没有做什么事情，没有读什么书，非常惭愧。倒是在上海玩的特别开心，仅做小记。</p>
</blockquote>
<p>可能是结婚后一直没有出去玩，各种压力有点大，领导听她的同事说有个VueConf的票去不了，然后她就转手买了下来，留下我一脸黑人问号，想了想就觉得去上海玩玩也行，正好趁端午，去之后还遇到了同事，想来也是挺神奇的。 五天四晚上海之行就迪士尼玩的最嗨皮。</p>
<a id="more"></a>

<blockquote>
<p>Ps: 这是我19年6月写的,之前域名过期，重新折腾了一下博客，离本文记录时间已经过去了一段时间，请谨慎参考。</p>
</blockquote>
<h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><p> 总共去了五天四晚，临时起意去苏州玩了一天，剩下领导开了一天的会，我去了上海野生动物园，外滩玩了一天半，迪士尼玩了两天，很开心，迪士尼是个不错的地方，可能也因为我没有长大。</p>
<h3 id="6月7日"><a href="#6月7日" class="headerlink" title="6月7日"></a>6月7日</h3><p>领导买的票是7点的，早上四点三十分就起床, 五点三十分打车前往北京南站，虽然是节假日，早上7点到达北京南还是全程特别通畅, 乘坐G5次复兴号高铁出发前往上海，历时四小时40分钟 在当天中午11点四十到达上海站。 我们两都是第一次坐复兴号，刚上去还挺激动的，像个好奇宝宝，研究了半天也没看出来与和谐号有什么特别本质的区别，没过一会就困得不行了。</p>
<p>在6号就提前收拾好了行李，买好7号的早餐，结果早餐忘了吃了；看了上海的天气，带了一把遮阳伞，一把雨伞，随身的行李拉了一个拉杆箱，明明取了纸质票，拿身份证给刷进去乘车了，纸质票都想不起来扔哪里了。</p>
<p>快到南京的时候，斜对面座位有两个女生，也是出来玩的，突然临时起意，说是去南京玩半天，下午或者晚上再从南京坐车到上海酒店。我和领导当时就震惊了，还有这种操作？ 我们两个心里也痒痒，商量要不也从南京下车，先看看金陵景色，后来想到基友还在上海站说要接我，还有点担心买不到晚上回上海的车票。</p>
<p>11点四十到上海车站后基友说他还在路上，得半个多小时，我们提前在手机上下载了《上海地铁metro大都会》 下了高铁之后还得先出站去地面，然后再下到地铁站，上海站应该是比较久远了，很小，很旧，也是脏乱差。在上海站对面乘坐的地铁1号线，到人民广场和基友约定会师，我们到了之后等了十来分钟，基友还没到，眼看领导就要冲着香奈儿店进去压压惊了，谢天谢地，基友终于到了，一个在上海工作了四年的人，给我打电话问我他下了地铁该怎么走，去哪个口？ 我一瞬间有点恍惚，感觉是个坑。</p>
<p>在人民广场吃的饭，之前看游记说这个如何如何好，旧上海的风格巴拉巴拉的，我不太喜欢，那地铁的闸机口好像跟我有仇，出去之后觉得像是老校区的宿舍，破破烂烂的，来之前在大众点评上找了一个好评最多的火锅《老灶福大刀腰片火锅店》 离地铁站也不近，芝麻酱我看了一眼就放弃了，领导也放弃了，服务态度也不行，火锅做的也一般，事实证明：不要在上海吃重庆火锅！！！！  为国民生产总值贡献了230人民币，基友付了账。</p>
<p>从人民广场乘2号线区酒店，地铁站的闸机还是不肯放过我，到陆家嘴下地铁，走了十来分钟终于到酒店了，这个时候都快累死了。出发前半个多月在招行300+上订了上海凯宾斯基的酒店，订了三晚的一个江景房，一晚上八百，说是江景，黄浦江只能看到的是很小的一部分，有点后悔没有订文华东方或者江对面的W酒店。酒店一般，服务也一般，办理入住很慢，也挺混乱，领导和基友完全没有地方休息，就在大堂干等着办理手续，真的差极了！</p>
<p>本来预计两点就能出去玩的，结果办理完入住，放完行李都快四点半了，领导其实都已经不想动了，还是坚持陪我和基友在外滩逛了逛，去南京路转了转，在南京路就看见了银银银，一家店都没进去，我和领导都不太喜欢往人堆里挤 非常的不适应。很快就走完了整个南京路，据说是东方时代广场，暗下决心以后去纽约坚决不去时代广场。  然后在酒店对面的外滩转了转，买了一个江底隧道的门票，一个人五十好像，基友说他也没坐过，结果就是三个人齐齐感到上当受骗，就很简单的隧道上挂了很简陋的LED灯管，既不真实，也不漂亮，一个车里面大概十个人吧，本来其他人还兴致冲冲的在前面拍照，领导不合时宜的说了一句：这不就是花五十块钱坐了个地铁吗？还没人地铁的广告好看，拍照的人瞬间就把手机收了起来，然后互相尴尬一笑。</p>
<p> 在外滩附近找个吃的超级难，在正大广场等了好久，终于在小南国吃了顿饭，感觉不如北京小南国，而且可能因为人多，根本没人理，服务很差。中途吃饭的时候一直打游戏，领导提醒，还把领导说了一嘴，惹领导生气了，非常不该的，以后出去玩，坚决不犯这样的错误。</p>
<p> 晚上刷盆友圈还看到有同事定位在东方明珠，一瞬间就觉得这个世界太小了吧，问了一嘴原来也是来参加VueConf大会的，再问人家说她的票是公司给的😐</p>
<h3 id="6月8日"><a href="#6月8日" class="headerlink" title="6月8日"></a>6月8日</h3><p> 早上六点就起床，起床就感觉可能晚了，早餐就没在凯宾斯基吃，据说凯宾斯基的早餐还可以，打车送领导到交通大学徐汇校区的vueConf,在校门口找了家庆丰包子铺，谁敢相信我从北京去上海吃庆丰包子。 领导去参加VueConf后，打电话叫基友一起去上海野生动物园，结果基友还没睡醒，我就先从徐汇出发，到野生动物园后等了会儿就买了票进去了，上海野生动物园据说是全国最大的野生动物园，读书那会儿领导一直喊着要去秦岭野生动物园，没想到来的第一个野生动物园居然是这里，领导还没来成😂，动物园不错。</p>
<h3 id="6月9日"><a href="#6月9日" class="headerlink" title="6月9日"></a>6月9日</h3><blockquote>
<p>临时起意想去苏州玩</p>
</blockquote>
<p>8号晚上买了去苏州的票，苏州基本就是冲着园林去，拙政园约了时间但是赶不上了，留园人少，精美，适合拍照，狮子林人超级多，可能是因为端午最后一天吧，苏博根本就约不到，之前也没准备来苏州玩，压根就没什么准备，倒是去了几个没什么名气的小的园林，感觉和天津的瓷房子倒是可以一起看。在从狮子林出来之后 根据大众点评的欢迎度，走了超长的路，吃了一个特别难吃的松鼠鱼，服务态度极其恶劣，在北京几年，从来没见过这样做生意的，可能也是因为我极少在北京景点吃饭。下午去金鸡湖随便看了看，超级热，来的时候又没什么人，坐不了船。等稍微凉爽了点，凑了十来个人，终于开船送我们到桃花岛上喂了点蚊子，五点多就匆匆往上海赶。可能是因为小时候课本里对苏州园林的渲染过于美好，我对苏州之行颇感失望，也可能从农村成长，不是很能理解这种园林之美。</p>
<h3 id="6月10日"><a href="#6月10日" class="headerlink" title="6月10日"></a>6月10日</h3><blockquote>
<p>买了迪士尼两日联票 但连续三天,实在是有点累了</p>
</blockquote>
<p>一瞬间都有点想上几天班休息一下了，早上起床后酒店的早餐的停止供应了，去买了点小杨生煎，领导吃了一个，我吃了半个，实在是不太喜欢。退了酒店之后就打车去万怡酒店，同样是招行300+精选，当时老眼昏花，而且被招行文案欺骗了，招行说他们的300+精选酒店都是五星级的，万怡酒店那里又写着万豪旗下，一直以为我订的是万豪酒店🙄  晚上回到酒店才发现呵呵哒。行李寄存到酒店后直接打车去了迪士尼，都快下午了，不知道为什么还有很多人在门口排队，下午刚进去就看到2点的花车，然后就忘了抢FP，事实是其实也没什么好项目的FP了，领导在急速光轮之后还想再玩，女生玩过山车真可怕！ 感觉我们第一天像是在试游玩，晚上灯光焰火秀也去的比较晚。</p>
<h3 id="6月11日"><a href="#6月11日" class="headerlink" title="6月11日"></a>6月11日</h3><p>养精蓄锐之后，我们11号玩的很疯，抢了飞越地平线和雷鸣山漂流的FP,然后买了一堆的FP，基本上除了《创》 剩下都玩了两三遍，加勒比海盗那个更是玩了五遍，迪士尼确实擅长造梦，欢乐谷给人的氛围是刺激，迪士尼则是另外一种。最惨的就是绳索挑战，之前领导给我和她买了特别厚实的雨衣雨靴，雷鸣山漂流玩之后扔掉的都觉得好可惜，也没溅到什么水，当时还很好奇一个男游客裤子、上衣全部湿透是怎么玩的漂流，能有这么多水； 绳索挑战的一条路线有个瀑布，得从旁边的峭壁上抓着石头横渡过去，领导有点害怕，抱着岩石不肯往前走，我在后面鼓励领导，然后瀑布的水哐哐的浇我，领导抱着石头大声的喊，后面一对小情侣笑得都站不起来了。走完之后我就意识到我应该是当天全园区获得瀑布最多的男人。 后续两次玩这个项目就没再敢走这条路线。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>迪士尼挺好玩，也挺贵，里面一个披萨198(还是298来着？) ，我们吃了两个没吃饱😒 上海有很多很不错的地方，陆家嘴值得去看看，苏州也挺好，有机会再去南京杭州看看吧！</p>
]]></content>
      <categories>
        <category>travel</category>
      </categories>
      <tags>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GitHub Actions 自动构建部署Hexo博客</title>
    <url>/hexo/use-actions-github/</url>
    <content><![CDATA[<blockquote>
<p>之前一直在使用Travis-CI部署Hexo博客,博客的源文件一直都在私有仓库中，只能只用<a href="https://travis-ci.com/" target="_blank" rel="noopener">https://travis-ci.com/</a>, 眼看自己的100次机会很快就要用完了，Github 发布Github Actions了， 就简单折腾了一些时间，现在也使用了一段时间了 分享下我的使用过程</p>
</blockquote>
<p>我个人比较坚持将代码尽可能的分离，<a href="https://blog.yangfan16.cn/hexo/use-sub-theme/">参考我的上一篇博客使用Git Submdule 分离Hexo主题</a>。 另外，<br>Hexo和NexT配置文件中包含一些不太适合公开的信息，比如leancloud的AK SK , 还有一些ApplicationID等等。这两个部分在我使用Github-actions的过程中造成了不少使用上的麻烦，解决的过程我尽可能详细的在文章中记录下来，方便下次查阅。</p>
<a id="more"></a>

<blockquote>
<p>Ps: <a href="https://xirikm.net/" target="_blank" rel="noopener">感谢xirikm博主的邮件答复和耐心解惑</a></p>
</blockquote>
<h2 id="关于GitHub-Actions"><a href="#关于GitHub-Actions" class="headerlink" title="关于GitHub Actions"></a>关于GitHub Actions</h2><p>GitHub Actions 是Github推出的又一款持续继承服务，功能类似于Travis-CI,但是直接与Github集成，可以在github页面直接查看构建和部署的过程，方便不少。<br>还有就是我的博客源文件仓库是私有仓库，只能免费使用Travis-ci.com构建一百次。 要想使用travis-ci.org还必须得公有仓库，Actions倒是没有这方面的条件。<br>此外 <a href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener">Github还推出了一个Actions MarketPlace</a>, 里面包含了不少他人提交的Actions; <a href="https://github.com/sdras/awesome-actions" target="_blank" rel="noopener">还有人搞了一个<br>awesome</a> 这就免去了重复写actions的过程。</p>
<p>官方文档给出了非常详解的解释和用例，<a href="https://help.github.com/en/actions" target="_blank" rel="noopener">具体请移步这里</a> , 中文文档翻译的稀碎，我英文不太好，还是有选择的看了些英文的文档。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><em>workflow</em> （工作流程）：持续集成一次运行的过程，就是一个 workflow。</li>
<li><em>job</em> （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</li>
<li><em>step</em>（步骤）：每个 job 由多个 step 构成，一步步完成。</li>
<li><em>action</em> （动作）：每个 step 可以依次执行一个或多个命令（action）。</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我的博客是有三个仓库 一个私有的博客主题文件仓库（NexT主题，fork后自己拉分支更新自己的配置）， 一个私有的博客源文件仓库， 使用git submodule 引用自己的私有主题仓库。 一个公有的github Page 仓库。</p>
<p>需要获取一个GitHub Personal Access Token 用来推送构建好的文件到公有的 GitHub Pages仓库, PAT(Personal Access Token)的创建过程：点击 GitHub 用户设置页面 最下方的 Developer setting ，然后选择 Personal access tokens 来生成一个 token，由于我们只需要能够对普通仓库 push 就行了，所以把 repo 部分勾上即可。</p>
<blockquote>
<p>Ps: 生成的 token 只会显示一次，一定要及时保存下来，否则就只能删除重新创建了</p>
</blockquote>
<p>创建两个安全环境变量: 点开博客源文件仓库上方的 Settings，点到左侧的 Secrets 项，添加两个环境变量 GH_REF 、GH_TOKEN，值分别填写自己的 GitHub Pages 仓库地址（不包含 https:// ）和刚刚申请到的PAT</p>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>准备工作做好之后就可以写GitHub Actions 配置文件了。</p>
<h3 id="触发条件和运行环境"><a href="#触发条件和运行环境" class="headerlink" title="触发条件和运行环境"></a>触发条件和运行环境</h3><p>设置在master分支上push操作的时候触发构建部署动作 使用最新的 Ubuntu 系统作为编译部署的环境，同时设置一个全局环境变量将时区修改为 Asia/Shanghai，具体的配置部分为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: MyBlog CI&#x2F;CD</span><br><span class="line">  </span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: </span><br><span class="line">      - master</span><br><span class="line">env:</span><br><span class="line">  TZ: Asia&#x2F;Shanghai</span><br><span class="line">  </span><br><span class="line">jobs:</span><br><span class="line">  blog-cicd:</span><br><span class="line">    name: Hexo blog build &amp; deploy</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    </span><br><span class="line">steps:</span><br><span class="line">............</span><br></pre></td></tr></table></figure>

<h3 id="检出代码和submodule"><a href="#检出代码和submodule" class="headerlink" title="检出代码和submodule"></a>检出代码和submodule</h3><p>由于我的主题文件是私有仓库，需要在检出的时候使用PAT。另外，.gitmodules文件中的url要是https格式而非ssh格式<a href="https://github.com/actions/checkout/issues/116" target="_blank" rel="noopener">参考这个issue</a>,<a href="https://github.community/t5/GitHub-Actions/How-to-checkout-a-private-submodule-from-a-github-action/td-p/33803" target="_blank" rel="noopener">还有这个社区文档</a></p>
<p>具体配置部分为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">steps:</span><br><span class="line">- name: Checkout codes</span><br><span class="line">  uses: actions&#x2F;checkout@v2</span><br><span class="line"></span><br><span class="line">- name: Checkout Private submodules</span><br><span class="line">  uses: actions&#x2F;checkout@v2</span><br><span class="line">  with:</span><br><span class="line">    repository: yangfan16&#x2F;hexo-theme-next</span><br><span class="line">    token: $&#123;&#123; secrets.GH_TOKEN &#125;&#125;</span><br><span class="line">    path: themes&#x2F;next</span><br><span class="line"></span><br><span class="line">  ............</span><br></pre></td></tr></table></figure>


<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>官方不建议直接缓存 node_modules 目录，所以这里设置的是 npm 的下载缓存目录 ~/.npm，这样后面仍需要使用 npm install 来安装依赖。使用的是 package-lock.json 文件的 hash 值来标识缓存是否可以命中，避免每次都要重新下载，从而加快构建速度。 除此之外使用gulp压缩混淆前端代码。</p>
<p>具体的配置部分:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: Setup node</span><br><span class="line">uses: actions&#x2F;setup-node@v1</span><br><span class="line">with:</span><br><span class="line">  node-version: &#39;13.x&#39;</span><br><span class="line"></span><br><span class="line">- name: Cache node modules</span><br><span class="line">uses: actions&#x2F;cache@v1</span><br><span class="line">with:</span><br><span class="line">    path: ~&#x2F;.npm</span><br><span class="line">    key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#39;**&#x2F;package-lock.json&#39;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">- name: Install dependencies</span><br><span class="line">run: |</span><br><span class="line">  npm install hexo-cli gulp -g</span><br><span class="line">  npm install</span><br><span class="line"></span><br><span class="line">- name: Generate files</span><br><span class="line">run: hexo clean &amp;&amp; hexo generate</span><br><span class="line"></span><br><span class="line">- name: Execute gulp task</span><br><span class="line">run:  gulp</span><br><span class="line">............</span><br></pre></td></tr></table></figure>

<h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><p>网上的解决方案大多是生成SSH and GPG keys 然后在配置文件中加载私钥。 步骤繁杂，配置文件中一堆手写ssh密钥，不安全也不优雅，需要先安装Hexo的环境，</p>
<p>我这边直接clone代码，然后push到我的Github Pages私有仓库文件里，具体的配置部分为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: Deploy blog</span><br><span class="line">run: |</span><br><span class="line">  git clone &quot;https:&#x2F;&#x2F;$&#123;&#123; secrets.GH_REF &#125;&#125;&quot; deploy_git</span><br><span class="line">  mv .&#x2F;deploy_git&#x2F;.git .&#x2F;public&#x2F;</span><br><span class="line">  cd .&#x2F;public</span><br><span class="line">  git config user.name &quot;yangfan&quot;</span><br><span class="line">  git config user.email &quot;yangfan9915@gmail.com&quot;</span><br><span class="line">  git add .</span><br><span class="line">  git commit -m &quot;GitHub Actions Auto Builder at $(date +&#39;%Y-%m-%d %H:%M:%S&#39;)&quot;</span><br><span class="line">  git push --force --quiet &quot;https:&#x2F;&#x2F;$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@$&#123;&#123; secrets.GH_REF &#125;&#125;&quot; master:master</span><br></pre></td></tr></table></figure>

<h3 id="完整配置文件"><a href="#完整配置文件" class="headerlink" title="完整配置文件"></a>完整配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: MyBlog CI&#x2F;CD</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: </span><br><span class="line">      - master</span><br><span class="line"></span><br><span class="line">env:</span><br><span class="line">  TZ: Asia&#x2F;Shanghai</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  blog-cicd:</span><br><span class="line">    name: Hexo blog build &amp; deploy</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout codes</span><br><span class="line">      uses: actions&#x2F;checkout@v2</span><br><span class="line"></span><br><span class="line">    - name: Checkout Private submodules</span><br><span class="line">      uses: actions&#x2F;checkout@v2</span><br><span class="line">      with:</span><br><span class="line">        repository: yangfan16&#x2F;hexo-theme-next</span><br><span class="line">        token: $&#123;&#123; secrets.GH_TOKEN &#125;&#125;</span><br><span class="line">        path: themes&#x2F;next</span><br><span class="line">      </span><br><span class="line">    - name: Setup node</span><br><span class="line">      uses: actions&#x2F;setup-node@v1</span><br><span class="line">      with:</span><br><span class="line">        node-version: &#39;13.x&#39;</span><br><span class="line"></span><br><span class="line">    - name: Cache node modules</span><br><span class="line">      uses: actions&#x2F;cache@v1</span><br><span class="line">      with:</span><br><span class="line">        path: ~&#x2F;.npm</span><br><span class="line">        key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#39;**&#x2F;package-lock.json&#39;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">    - name: Install dependencies</span><br><span class="line">      run: |</span><br><span class="line">        npm install hexo-cli gulp -g</span><br><span class="line">        npm install</span><br><span class="line"></span><br><span class="line">    - name: Generate files</span><br><span class="line">      run: hexo clean &amp;&amp; hexo generate</span><br><span class="line"></span><br><span class="line">    - name: Execute gulp task</span><br><span class="line">      run:  gulp</span><br><span class="line"></span><br><span class="line">    - name: Deploy blog</span><br><span class="line">      run: |</span><br><span class="line">        git clone &quot;https:&#x2F;&#x2F;$&#123;&#123; secrets.GH_REF &#125;&#125;&quot; deploy_git</span><br><span class="line">        mv .&#x2F;deploy_git&#x2F;.git .&#x2F;public&#x2F;</span><br><span class="line">        cd .&#x2F;public</span><br><span class="line">        git config user.name &quot;yangfan&quot;</span><br><span class="line">        git config user.email &quot;yangfan9915@gmail.com&quot;</span><br><span class="line">        git add .</span><br><span class="line">        git commit -m &quot;GitHub Actions Auto Builder at $(date +&#39;%Y-%m-%d %H:%M:%S&#39;)&quot;</span><br><span class="line">        git push --force --quiet &quot;https:&#x2F;&#x2F;$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@$&#123;&#123; secrets.GH_REF &#125;&#125;&quot; master:master</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将博客的构建部署方式更换为Github Actions之后非常方便，有问题排查也很方便，到目前为止，感觉还是比较舒服的</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git Submdule 分离Hexo主题</title>
    <url>/hexo/use-sub-theme/</url>
    <content><![CDATA[<blockquote>
<p>Hexo 博客应该与其主题进行分离，需要更新主题，或者使用的评论，分享组件不可用，只需要做很小的改动</p>
</blockquote>
<p>更重要的是，将代码copy到博客目录中，随博客一起推至Github等代码托管平台，但是Theme中的配置文件一同推了上去，其中包括不少appID,AK,SK这样的信息（例如leancloud）， 这些影响都是灾难级的。</p>
<p>使用Git Submodule 能够很好地解决这些问题 ，对主题进行单独的管理，使之成为一个单独的部件， 非常的棒！</p>
<a id="more"></a>

<blockquote>
<p>Ps: 这是我19年9月写的,之前博客域名过期，趁着春节将博客内容进行迁移，离本文记录时间已经过去了一段时间，请谨慎参考。</p>
</blockquote>
<h2 id="关于Git-Submodule"><a href="#关于Git-Submodule" class="headerlink" title="关于Git Submodule"></a>关于Git Submodule</h2><p>官方文档给出了非常详解的解释和用例，我们在生产中也有不少用到的地方; <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">具体请移步这里</a> , 在此不做赘述。</p>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在本地Clone主题文件(以NexT主题为例): </span><br><span class="line">cd $&#123;hexo&#125;  &#x2F;&#x2F;进入到Hexo的目录</span><br><span class="line">git submodule add https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新 _config.yml 使用NexT的主题</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>此时就拥有了两个仓库，一个是Hexo的，一个是NexT主题的，后者只有拉取并无修改的权限，且其中包含一些信息并不适合推入Github公有仓库，建立一个私有仓库是比较合适的（GitHub放开了私有仓库，后面准备用Travis CI，就不考虑GitLab了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd $&#123;hexo&#125;&#x2F;themes&#x2F;next  &#x2F;&#x2F;进入到子模块</span><br><span class="line">&#x2F;&#x2F;$&#123;github&#125; 单独去一个远程仓库的名称，默认是origin  既然在github上，我就设置为github</span><br><span class="line">git remote add $&#123;github&#125; git@github.com:$&#123;you_github_name&#125;&#x2F;$&#123;hexo-theme-next&#125;.git  &#x2F;&#x2F;$&#123;hexo-theme-next&#125; 是指你建立的私有的主题仓库名</span><br><span class="line">git push -u $&#123;github&#125; master</span><br></pre></td></tr></table></figure>

<p>拉取一个新的分支，并在上面进行自己的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b $&#123;release&#125;</span><br><span class="line">&#x2F;&#x2F; 对主题进行个性化的修改和配置，增加第三方的插件，[具体请参考官方文档](https:&#x2F;&#x2F;hexo-theme-next.netlify.com&#x2F;docs&#x2F;)</span><br><span class="line">&#x2F;&#x2F;与本文主题无关，先行略过</span><br><span class="line">git push -u $&#123;github&#125; $&#123;release&#125;</span><br></pre></td></tr></table></figure>

<p>打开.gitmodule 文件，将其中的URL改为自己的仓库，并指定使用分支为release分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   [submodule &quot;themes&#x2F;next&quot;]</span><br><span class="line">path &#x3D; themes&#x2F;next</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;$&#123;github_name&#125;&#x2F;$&#123;git_repo_name&#125;</span><br><span class="line">branch &#x3D; release</span><br></pre></td></tr></table></figure>

<p>通过以上简单的修改，可以将Hexo的主题与博客分离出来，使用私有仓库免去秘钥信息的泄漏，觉得上传到远程托管平台就不安全的话，可以单独生成线上使用的配置文件，就没有必要使用私有仓库。 </p>
<p>当然，这样的也有一点问题，升级原来的主题的时候可能会有冲突，在自己的分支上合并master分支的代码,可能需要手动解决。 总体来说还是比较值得的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尽可能的将单独的模块分离出来，升级维护都是很方便的事情，也是编码的常见操作。安全问题很容易被忽略,任何秘钥的信息都不应该由自己主动泄漏出去。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬取微信公众号上的图片</title>
    <url>/python/wechat-pics/</url>
    <content><![CDATA[<blockquote>
<p>最近斗图老输，完全不符合我表情包之王，国家殿堂级斗图高手的身份，一直想着怎么给我的表情包扩充一下新的血液；在B站也刷到半佛仙人的视频，发现他的表情包是多而沙雕，也刷到了桂大佬做的怎么下载,就顺着写了一下。现在的版本暂时只下载一篇文章中的，后续版本下载公众号中全部文章的图片。</p>
</blockquote>
<a id="more"></a>

<p>我的Mac OS系统是10.15.4版本的，使用PyCharm开发，开始写的时候python版本是3.7的，后续升级成为了3.8.2</p>
<h3 id="安装使用3-8-2版本的python"><a href="#安装使用3-8-2版本的python" class="headerlink" title="安装使用3.8.2版本的python"></a>安装使用3.8.2版本的python</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade</span><br><span class="line"># 安装pyenv 我之前没有，已经安装的可以不用</span><br><span class="line">brew install pyenv </span><br><span class="line"># 我使用 oh-my-zsh SHELL</span><br><span class="line">echo &#39;export PATH&#x3D;&quot;$(pyenv root)&#x2F;shims:$PATH&quot;&#39; &gt;&gt; ~&#x2F;.zshrc</span><br><span class="line">source ~&#x2F;.zshrc</span><br><span class="line"># 目前最新的python3.8.2 选择适合的</span><br><span class="line">pyenv install --list | grep 3.8</span><br><span class="line"># 安装3.8.2</span><br><span class="line">pyenv install 3.8.2</span><br><span class="line"># 查看目前的python</span><br><span class="line">pyenv versions</span><br><span class="line">pyenv local 3.8.2</span><br><span class="line"># 设置全局 pyenv --help可以查看</span><br><span class="line">pyenv global 3.8.2</span><br><span class="line"># type查看</span><br><span class="line">type -a python</span><br><span class="line"># 重新打开终端</span><br><span class="line">python -V</span><br><span class="line"># 顺手升级pip</span><br><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure>


<h3 id="PyCharm-使用pytho3-8-2"><a href="#PyCharm-使用pytho3-8-2" class="headerlink" title="PyCharm 使用pytho3.8.2"></a>PyCharm 使用pytho3.8.2</h3><p>在项目的右下角可以看到PyCharm当前使用的Python解释器版本，默认是跟谁系统的3.7.2(brew install python)。 通过以下操作可以将其更换为3.8.2</p>
<p>Preferences(Command + ,) -&gt; Project -&gt; Python Interpreter -&gt; 选择Python3.8.2。 如下图所示。<br><img data-src="https://images.yangfan16.cn/pycharm-interpreter.jpeg" alt="PyCharm解释器配置"></p>
<h3 id="爬取页面图片的url"><a href="#爬取页面图片的url" class="headerlink" title="爬取页面图片的url"></a>爬取页面图片的url</h3><p>搜狗微信可以直接查看微信的连接，直接用搜狗微信公众号的链接即可，使用requests即可查看到， 查看页面的元素就能看到图片连接都在data-src里面，正则匹配一下就可以</p>
<p>需要安装的库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_urls(url):</span><br><span class="line">    try:</span><br><span class="line">        html &#x3D; requests.get(url, timeout&#x3D;30).text</span><br><span class="line">    except requests.exceptions.SSLError:</span><br><span class="line">        html &#x3D; requests.get(url, verify&#x3D;False, timeout&#x3D;30).text</span><br><span class="line">    except TimeoutError:</span><br><span class="line">        print(&#39;请求超时&#39;)</span><br><span class="line">    except Exception:</span><br><span class="line">        print(&#39;获取图片链接失败&#39;)</span><br><span class="line">    src &#x3D; re.compile(r&#39;data-src&#x3D;&quot;(.*?)&quot;&#39;)</span><br><span class="line">    urls &#x3D; re.findall(src, html)</span><br><span class="line">    if urls is not None:</span><br><span class="line">        url_list &#x3D; []</span><br><span class="line">        for url in urls:</span><br><span class="line">            url_list.append(url)</span><br><span class="line">        return url_list</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"># main 函数</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;</span><br><span class="line">    # 这链接经常会过期，自己去https:&#x2F;&#x2F;weixin.sogou.com&#x2F; 搜索可用的链接</span><br><span class="line">    # 我使用的文章是 《体育考试作弊会毁了你》</span><br><span class="line">    sample &#x3D; &quot;https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?src&#x3D;11&amp;timestamp&#x3D;1588487130&amp;ver&#x3D;2315&amp;signature&#x3D;EbcpQeUVIa3ICzS4H7mTb5mt*o2SrYuEC6Ff0Pr7o7wtVG-OHb-IiSek5Wt6cUFR-X8zwrV5Nri5aoyVLH0ys3kLPOnTfks3ni0RhtPdKHios6B9XTkHhuyOKzNXShF-&amp;new&#x3D;1&quot;</span><br><span class="line">    img_urls &#x3D; get_urls(sample)</span><br><span class="line">    print(img_urls)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一开始不知道为啥我一导入requests包运行程序就会异常退出，纠结了半天才找到问题<br>因为我的mac的/usr/local/lib 里面没有libssl.dylib 和 libcrypto.dylib这两个文件<br>旧版本的openssl也可能会有相同问题。 如下操作即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;openssl@1.1&#x2F;1.1.1g&#x2F;lib</span><br><span class="line">sudo cp libssl.1.1.dylib libcrypto.1.1.dylib &#x2F;usr&#x2F;local&#x2F;lib&#x2F;</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;lib</span><br><span class="line"># 如果有旧的最好备份一下 mv</span><br><span class="line">mv libssl.dylib libssl_bak.dylib</span><br><span class="line">mv libcrypto.dylib libcrypto_bak.dylib</span><br><span class="line"># 建立软链</span><br><span class="line">sudo ln -s libssl.1.1.dylib libssl.dylib</span><br><span class="line">sudo ln -s libcrypto.1.1.dylib libcrypto.dylib</span><br></pre></td></tr></table></figure>

<p>运行一下就能看到我们已经把这个文章中的图片连接已经全部得到了。</p>
<h3 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建保存图片的文件夹</span><br><span class="line">def mkdir(base_path):</span><br><span class="line">    isExists &#x3D; os.path.exists(base_path)</span><br><span class="line">    if not isExists:</span><br><span class="line">        print(&#39;创建目录&#39;)</span><br><span class="line">        os.makedirs(base_path)  # 创建目录</span><br><span class="line">        os.chdir(base_path)  # 切换到创建的文件夹</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        print(&#39;目录已存在，即将保存！&#39;)</span><br><span class="line">        return False</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"># 下载图片并写入到指定的文件夹中</span><br><span class="line">def download(base_path, image_urls):</span><br><span class="line">    for url in image_urls:</span><br><span class="line">        filename &#x3D; base_path + url.split(&#39;&#x2F;&#39;)[-2] + &#39;.&#39; + url.split(&#39;&#x3D;&#39;)[-1]</span><br><span class="line">        try:</span><br><span class="line">            with open(filename, &#39;wb+&#39;) as f:</span><br><span class="line">                try:</span><br><span class="line">                    f.write(requests.get(url, timeout&#x3D;30).content)</span><br><span class="line">                    print(&#39;成功下载图片：&#39;, filename)</span><br><span class="line">                except requests.exceptions.SSLError:</span><br><span class="line">                    f.write(requests.get(url, verify&#x3D;False, timeout&#x3D;30).content)</span><br><span class="line">                    print(&#39;成功下载图片：&#39;, filename)</span><br><span class="line">        except FileNotFoundError:</span><br><span class="line">            print(&#39;下载失败！！没有找到对应图片目前，请检查路径：&#39;, filename)</span><br><span class="line">            pass</span><br><span class="line">        except TimeoutError:</span><br><span class="line">            print(&#39;下载超时：&#39;, filename)</span><br><span class="line">            pass</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&#39;非正常图片，直接忽略：&#39;, filename, e)</span><br><span class="line">            pass</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># main函数</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    sample &#x3D; &quot;https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?src&#x3D;11&amp;timestamp&#x3D;1588487130&amp;ver&#x3D;2315&amp;signature&#x3D;EbcpQeUVIa3ICzS4H7mTb5mt*o2SrYuEC6Ff0Pr7o7wtVG-OHb-IiSek5Wt6cUFR-X8zwrV5Nri5aoyVLH0ys3kLPOnTfks3ni0RhtPdKHios6B9XTkHhuyOKzNXShF-&amp;new&#x3D;1&quot;</span><br><span class="line">    img_urls &#x3D; get_urls(sample)</span><br><span class="line">    base_path &#x3D; r&#39;.&#x2F;weichat_pics&#x2F;&#39;</span><br><span class="line">    try:</span><br><span class="line">        mkdir(base_path)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;建立文件异常&quot;, e)</span><br><span class="line">    print(&quot;保存图片文件夹正常&quot;)</span><br><span class="line">    download(base_path, img_urls)</span><br></pre></td></tr></table></figure>


<p>再次运行代码就能看到，已经将这篇文章中所有的图片均已经下载到指定的文件夹中。</p>
<h3 id="使用百度的OCR重命名文件"><a href="#使用百度的OCR重命名文件" class="headerlink" title="使用百度的OCR重命名文件"></a>使用百度的OCR重命名文件</h3><h4 id="创建百度文字识别应用"><a href="#创建百度文字识别应用" class="headerlink" title="创建百度文字识别应用"></a>创建百度文字识别应用</h4><p>百度账号应该都有，<a href="https://ai.baidu.com/" target="_blank" rel="noopener">直接到百度AI只能开放平台</a>，登录后直接进入到控制台，<a href="https://console.bce.baidu.com/ai/?fromai=1#/ai/ocr/overview/index" target="_blank" rel="noopener">点击文字识别</a>。创建应用即可。可以在下面看到调用次数和API类型，可惜就是给的免费QPS低了点。有了应用之后直接使用百度提供的SDK python-aip。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install baidu-aip</span><br></pre></td></tr></table></figure>

<h4 id="使用OCR识别图片中的文字"><a href="#使用OCR识别图片中的文字" class="headerlink" title="使用OCR识别图片中的文字"></a>使用OCR识别图片中的文字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def baiduOCR(picfile):</span><br><span class="line">    &quot;&quot;&quot;利用百度api识别文本，并保存提取的文字</span><br><span class="line">    把下面的ID KEY 和SK替换成自己的就可以了</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    APP_ID &#x3D; &#39;xxxxxx&#39;</span><br><span class="line">    API_KEY &#x3D; &#39;xxxxxx&#39;</span><br><span class="line">    SECRECT_KEY &#x3D; &#39;xxxxxxxx&#39;</span><br><span class="line">    client &#x3D; AipOcr(APP_ID, API_KEY, SECRECT_KEY)</span><br><span class="line">    i &#x3D; open(picfile, &#39;rb&#39;)</span><br><span class="line">    img &#x3D; i.read()</span><br><span class="line">    try:</span><br><span class="line">        message &#x3D; client.basicGeneral(img)[&#39;words_result&#39;]  # 通用文字识别</span><br><span class="line">        value &#x3D; []</span><br><span class="line">        for j in message:</span><br><span class="line">            value.append(j[&#39;words&#39;])</span><br><span class="line">        t &#x3D; &#39;&#39;.join(value)</span><br><span class="line">        title &#x3D; t.replace(&#39;&#x2F;&#39;, &#39;&#39;).replace(&#39;\\&#39;, &#39;&#39;).replace(&#39;:&#39;, &#39;&#39;).replace(&#39;*&#39;, &#39;&#39;).replace(&#39;?&#39;, &#39;&#39;).replace(&#39;&lt;&#39;, &#39;&#39;) \</span><br><span class="line">            .replace(&#39;&gt;&#39;, &#39;&#39;).replace(&#39;|&#39;, &#39;&#39;).replace(&#39;.&#39;, &#39;&#39;)</span><br><span class="line">        # .strip(&#39;&#x2F;&#39;).strip(&#39;\\&#39;).strip(&#39;:&#39;).strip(&#39;*&#39;).strip(&#39;?&#39;).strip(&#39;&lt;&#39;).strip(&#39;&gt;&#39;).strip(&#39;|&#39;).strip(&#39;.&#39;)</span><br><span class="line">        timestamp &#x3D; int(time.time())</span><br><span class="line">        if title &#x3D;&#x3D; &quot;&quot; or title &#x3D;&#x3D; None:</span><br><span class="line">            title &#x3D; timestamp</span><br><span class="line">            return title</span><br><span class="line">        i.close()</span><br><span class="line">        return title</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">        print(&#39;此图片类型无法识别&#39;)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"># 修改下download函数，在下载完一张图片后就试着重命名下</span><br><span class="line">def download(base_path, image_urls):</span><br><span class="line">    for url in image_urls:</span><br><span class="line">        filename &#x3D; base_path + url.split(&#39;&#x2F;&#39;)[-2] + &#39;.&#39; + url.split(&#39;&#x3D;&#39;)[-1]</span><br><span class="line">        try:</span><br><span class="line">            with open(filename, &#39;wb+&#39;) as f:</span><br><span class="line">                try:</span><br><span class="line">                    f.write(requests.get(url, timeout&#x3D;30).content)</span><br><span class="line">                    print(&#39;成功下载图片：&#39;, filename)</span><br><span class="line">                except requests.exceptions.SSLError:</span><br><span class="line">                    f.write(requests.get(url, verify&#x3D;False, timeout&#x3D;30).content)</span><br><span class="line">                    print(&#39;成功下载图片：&#39;, filename)</span><br><span class="line">        except FileNotFoundError:</span><br><span class="line">            print(&#39;下载失败！！没有找到对应图片目前，请检查路径：&#39;, filename)</span><br><span class="line">            pass</span><br><span class="line">        except TimeoutError:</span><br><span class="line">            print(&#39;下载超时：&#39;, filename)</span><br><span class="line">            pass</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&#39;非正常图片，直接忽略：&#39;, filename, e)</span><br><span class="line">            pass</span><br><span class="line">        try:</span><br><span class="line">            title &#x3D; baiduOCR(filename)</span><br><span class="line">            timestamp &#x3D; int(time.time())</span><br><span class="line">            pic_type &#x3D; url.split(&#39;&#x3D;&#39;)[-1]</span><br><span class="line">            if pic_type &#x3D;&#x3D; &#39;gif&#39;:</span><br><span class="line">                new_name &#x3D; base_path + str(timestamp) + &#39;.&#39; + pic_type</span><br><span class="line">            else:</span><br><span class="line">                new_name &#x3D; base_path + str(title) + &#39;.&#39; + pic_type</span><br><span class="line">                os.rename(filename, new_name)</span><br><span class="line">            print(&#39;文件重命名成功% s&#39; % (new_name))</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&#39;重命名失败！忽略&#39;, e)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Ps: pip instll aip 和pip install baidu-aip下载是两个包，前者需要暂时卸载了</p>
</blockquote>
<p>再次运行程序，基本就能看到已经有些字迹清晰完整的图片已经成功重新命名。</p>
<h4 id="完整程序代码"><a href="#完整程序代码" class="headerlink" title="完整程序代码"></a>完整程序代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">from aip import AipOcr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def baiduOCR(picfile):</span><br><span class="line">    &quot;&quot;&quot;利用百度api识别文本，并保存提取的文字</span><br><span class="line">    把下面的ID KEY 和SK替换成自己的就可以了</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    APP_ID &#x3D; &#39;xxxxxxxxx&#39;</span><br><span class="line">    API_KEY &#x3D; &#39;xxxxxxxxx&#39;</span><br><span class="line">    SECRECT_KEY &#x3D; &#39;xxxxxxxxx&#39;</span><br><span class="line">    client &#x3D; AipOcr(APP_ID, API_KEY, SECRECT_KEY)</span><br><span class="line">    i &#x3D; open(picfile, &#39;rb&#39;)</span><br><span class="line">    img &#x3D; i.read()</span><br><span class="line">    try:</span><br><span class="line">        message &#x3D; client.basicGeneral(img)[&#39;words_result&#39;]  # 通用文字识别</span><br><span class="line">        value &#x3D; []</span><br><span class="line">        for j in message:</span><br><span class="line">            value.append(j[&#39;words&#39;])</span><br><span class="line">        t &#x3D; &#39;&#39;.join(value)</span><br><span class="line">        title &#x3D; t.replace(&#39;&#x2F;&#39;, &#39;&#39;).replace(&#39;\\&#39;, &#39;&#39;).replace(&#39;:&#39;, &#39;&#39;).replace(&#39;*&#39;, &#39;&#39;).replace(&#39;?&#39;, &#39;&#39;).replace(&#39;&lt;&#39;, &#39;&#39;) \</span><br><span class="line">            .replace(&#39;&gt;&#39;, &#39;&#39;).replace(&#39;|&#39;, &#39;&#39;).replace(&#39;.&#39;, &#39;&#39;)</span><br><span class="line">        # .strip(&#39;&#x2F;&#39;).strip(&#39;\\&#39;).strip(&#39;:&#39;).strip(&#39;*&#39;).strip(&#39;?&#39;).strip(&#39;&lt;&#39;).strip(&#39;&gt;&#39;).strip(&#39;|&#39;).strip(&#39;.&#39;)</span><br><span class="line">        timestamp &#x3D; int(time.time())</span><br><span class="line">        if title &#x3D;&#x3D; &quot;&quot; or title &#x3D;&#x3D; None:</span><br><span class="line">            title &#x3D; timestamp</span><br><span class="line">            return title</span><br><span class="line">        i.close()</span><br><span class="line">        return title</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">        print(&#39;此图片类型无法识别&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_urls(url):</span><br><span class="line">    try:</span><br><span class="line">        html &#x3D; requests.get(url, timeout&#x3D;30).text</span><br><span class="line">    except requests.exceptions.SSLError:</span><br><span class="line">        html &#x3D; requests.get(url, verify&#x3D;False, timeout&#x3D;30).text</span><br><span class="line">    except TimeoutError:</span><br><span class="line">        print(&#39;请求超时&#39;)</span><br><span class="line">    except Exception:</span><br><span class="line">        print(&#39;获取图片链接失败&#39;)</span><br><span class="line">    src &#x3D; re.compile(r&#39;data-src&#x3D;&quot;(.*?)&quot;&#39;)</span><br><span class="line">    urls &#x3D; re.findall(src, html)</span><br><span class="line">    if urls is not None:</span><br><span class="line">        url_list &#x3D; []</span><br><span class="line">        for url in urls:</span><br><span class="line">            url_list.append(url)</span><br><span class="line">        return url_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def mkdir(base_path):</span><br><span class="line">    isExists &#x3D; os.path.exists(base_path)</span><br><span class="line">    if not isExists:</span><br><span class="line">        print(&#39;创建目录&#39;)</span><br><span class="line">        os.makedirs(base_path)  # 创建目录</span><br><span class="line">        os.chdir(base_path)  # 切换到创建的文件夹</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        print(&#39;目录已存在，即将保存！&#39;)</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def download(base_path, image_urls):</span><br><span class="line">    for url in image_urls:</span><br><span class="line">        filename &#x3D; base_path + url.split(&#39;&#x2F;&#39;)[-2] + &#39;.&#39; + url.split(&#39;&#x3D;&#39;)[-1]</span><br><span class="line">        try:</span><br><span class="line">            with open(filename, &#39;wb+&#39;) as f:</span><br><span class="line">                try:</span><br><span class="line">                    f.write(requests.get(url, timeout&#x3D;30).content)</span><br><span class="line">                    print(&#39;成功下载图片：&#39;, filename)</span><br><span class="line">                except requests.exceptions.SSLError:</span><br><span class="line">                    f.write(requests.get(url, verify&#x3D;False, timeout&#x3D;30).content)</span><br><span class="line">                    print(&#39;成功下载图片：&#39;, filename)</span><br><span class="line">        except FileNotFoundError:</span><br><span class="line">            print(&#39;下载失败！！没有找到对应图片目前，请检查路径：&#39;, filename)</span><br><span class="line">            pass</span><br><span class="line">        except TimeoutError:</span><br><span class="line">            print(&#39;下载超时：&#39;, filename)</span><br><span class="line">            pass</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&#39;非正常图片，直接忽略：&#39;, filename, e)</span><br><span class="line">            pass</span><br><span class="line">        try:</span><br><span class="line">            title &#x3D; baiduOCR(filename)</span><br><span class="line">            timestamp &#x3D; int(time.time())</span><br><span class="line">            pic_type &#x3D; url.split(&#39;&#x3D;&#39;)[-1]</span><br><span class="line">            if pic_type &#x3D;&#x3D; &#39;gif&#39;:</span><br><span class="line">                new_name &#x3D; base_path + str(timestamp) + &#39;.&#39; + pic_type</span><br><span class="line">            else:</span><br><span class="line">                new_name &#x3D; base_path + str(title) + &#39;.&#39; + pic_type</span><br><span class="line">                os.rename(filename, new_name)</span><br><span class="line">            print(&#39;文件重命名成功% s&#39; % (new_name))</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&#39;重命名失败！忽略&#39;, e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    sample &#x3D; &quot;https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?src&#x3D;11&amp;timestamp&#x3D;1588487130&amp;ver&#x3D;2315&amp;signature&#x3D;EbcpQeUVIa3ICzS4H7mTb5mt*o2SrYuEC6Ff0Pr7o7wtVG-OHb-IiSek5Wt6cUFR-X8zwrV5Nri5aoyVLH0ys3kLPOnTfks3ni0RhtPdKHios6B9XTkHhuyOKzNXShF-&amp;new&#x3D;1&quot;</span><br><span class="line">    img_urls &#x3D; get_urls(sample)</span><br><span class="line">    base_path &#x3D; r&#39;.&#x2F;weichat_pics&#x2F;&#39;</span><br><span class="line">    try:</span><br><span class="line">        mkdir(base_path)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;建立文件异常&quot;, e)</span><br><span class="line">    print(&quot;保存图片文件夹正常&quot;)</span><br><span class="line">    download(base_path, img_urls)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
